{"title":"js Number详解","slug":"js Number详解","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-20T02:26:17.709Z","comments":true,"path":"api/articles/js Number详解.json","photos":[],"link":"","excerpt":"TL;DRNumber 最大安全整数为 Math.pow(2, 53) - 1Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 Math.pow(2, 970)位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位","covers":["https://ws1.sinaimg.cn/large/006tKfTcly1g18c4pud5dj30hx02st9q.jpg"],"content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>Number 最大安全整数为 <code>Math.pow(2, 53) - 1</code></li>\n<li>Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 <code>Math.pow(2, 970)</code></li>\n<li>位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"文章思路\"><a href=\"#文章思路\" class=\"headerlink\" title=\"文章思路\"></a>文章思路</h2><ol>\n<li>描述 IEEE754 64双精度表示法</li>\n<li>推出 Infinity、Number.MAX_VALUE、Number.MIN_VALUE 的表述</li>\n<li>进一步推出 Number 的最大安全数表示，为什么是 Math.pow(2, 53) - 1</li>\n<li>分析位运算 32 位转换，如何将 64 位转换成 32 位</li>\n</ol>\n<h2 id=\"IEEE754-双精度表示\"><a href=\"#IEEE754-双精度表示\" class=\"headerlink\" title=\"IEEE754 双精度表示\"></a>IEEE754 双精度表示</h2><p>根据 IEEE754 标准规定，一个双精度浮点数可以表示为:</p>\n<blockquote>\n<p>value = 符号位(S) x 尾数(M) x Math.pow(2, E)</p>\n</blockquote>\n<ol>\n<li>S 符号位，决定数字的正负</li>\n<li>M 尾数位，1 &lt;= M &lt; 2</li>\n<li>E 表示数字指数</li>\n</ol>\n<p>在内存中的表示如下：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1g18c4pud5dj30hx02st9q.jpg\" alt=\"双精度浮点数在内存中的表示\"></p>\n<ol>\n<li>sign 1 位，exponent 11 位，significand 52 位</li>\n<li>S 表示符号位，0 为正，1 为负</li>\n<li>exponent 不是公式中 Math.pow(2, E) 中的 E，二是 E + 1023</li>\n<li>前面提到，1 &lt;= M &lt; 2，可以表示 1.xxxxxx，其中 xxxxxxx 即是用 significand 存储</li>\n</ol>\n<blockquote>\n<p>参考</p>\n<ol>\n<li><a href=\"https://link.zhihu.com/?target=http%3A//www.csee.umbc.edu/~tsimo1/CMSC455/IEEE-754-2008.\" target=\"_blank\" rel=\"noopener\">IEEE754</a></li>\n<li><a href=\"http://bartaz.github.io/ieee754-visualization/\" target=\"_blank\" rel=\"noopener\">IEEE754 可视化</a></li>\n</ol>\n</blockquote>\n<h3 id=\"Infinity、0、MAX-VALUE、MIN-VALUE\"><a href=\"#Infinity、0、MAX-VALUE、MIN-VALUE\" class=\"headerlink\" title=\"Infinity、0、MAX_VALUE、MIN_VALUE\"></a>Infinity、0、MAX_VALUE、MIN_VALUE</h3><p>IEEE754 标准规定，exponent 全1和全0都有特殊含义，不算正常指数。</p>\n<ol>\n<li>全0：用来表示带符号的 0（尾数为0）或下溢数（尾数不为0）</li>\n<li>全1：用来表示Inifinity（尾数为0）或 NaN （尾数不为0）</li>\n<li>其他：代表 Math.pow(2, e)，其中 -1022 &lt;= e &lt;= 1023，因为 -1023 和 1024 已有特殊含义</li>\n</ol>\n<p>由此可知:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 无穷大</span><br><span class=\"line\">Math.pow(2, 1024) === Inifity</span><br><span class=\"line\"></span><br><span class=\"line\">// 0，因为 e最小为 -1022，把默认的 1 再左移 53 位，尾数即为 0</span><br><span class=\"line\">Math.pow(2, -1022) * Math.pow(2, -53) === 0</span><br></pre></td></tr></table></figure></p>\n<p>由此可轻易推断出，MIN_VALUE 和 MAX_VALUE<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MIN_VALUE 为：最小指数 x 最小尾数</span><br><span class=\"line\">Number.MIN_VALUE === Math.pow(2，-1022) * Math.pow(2, -52);</span><br><span class=\"line\"></span><br><span class=\"line\">// MAX_VALUE 为：最大指数 x 最大尾数</span><br><span class=\"line\">Number.MAX_VALUE === Math.pow(2, 1023) * 1.xxxxxx</span><br><span class=\"line\">                 === Math.pow(2, 971) * (Math.pow(2, 53) - 1) // 将尾数右移 52 位</span><br></pre></td></tr></table></figure></p>\n<p>所以 Infinity 和 Number.MAX_VALUE 不是一个数量级的。Infinity 比 Number.MAX_VALUE 多了<code>Math.pow(2, 971)</code>。Number.MAX_VALUE 只有在 significand 多一个比特位才会被表示为 Infinity<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Math.pow(2, 54) - 1) * Math.pow(2, 970) - (Math.pow(2, 53) -1) * Math.pow(2, 971) === Math.pow(2, 970)</span><br></pre></td></tr></table></figure></p>\n<p>也就是说，Number.MAX_VALUE 必须要加上一个被 IEEE754 四舍五入为 Math.pow(2, 970) 的数，才能被转换为 Infinity</p>\n<h3 id=\"Number-MAX-SAFE-INTEGER\"><a href=\"#Number-MAX-SAFE-INTEGER\" class=\"headerlink\" title=\"Number.MAX_SAFE_INTEGER\"></a>Number.MAX_SAFE_INTEGER</h3><p>javascript 的最大安全数为 Number.MAX_SAFE_INTEGER，即：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.pow(2, 53) - 1 === Number.MAX_SAFE_INTEGER</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么 Math.pow(2, 53) - 1 才是最大安全整数呢？</strong></p>\n<p>IEEE754 要求浮点数以规范形式存储，即小数点前有一位非零数字。对于二进制数，非零数字只有 1。所以IEEE754在存储时省略了这个小数点前面的1，只存储小数点后面的位。前面我们说过，significand 总共有 52 位，加上隐藏的一位1，总共有 53 位表示的二进制数，在多的会被截断，也就是精读丢失。那么最大的整数即是 53 位 1，位 Math.pow(2, 53) - 1。</p>\n<p><strong>为什么不是 Math.pow(2, 53) 呢？因为 Math.pow(2, 53) 后面全是 0，截断也没关系呀？</strong></p>\n<p>就是因为有截断这个动作，所以 Math.pow(2, 53) === Math.pow(2, 53) + 1，那么 Math.pow(2, 53) 就是不安全的。“它可以被不安全的数表示”</p>\n<h3 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h3><p>JS 在将两个整数进行位运算时，会先自动转换为32位有符号整数，完成后再将结果转换为64位。再转换为32位时，高子节将会被截断。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" target=\"_blank\" rel=\"noopener\">按位操作符</a>;</p>\n","categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"number","slug":"number","count":1,"path":"api/tags/number.json"}]}