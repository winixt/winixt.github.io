{"title":"js 异步进化史之Promise","slug":"js异步进化史之Promise","date":"2019-02-24T04:20:08.112Z","updated":"2019-02-24T04:20:08.112Z","comments":true,"path":"api/articles/js异步进化史之Promise.json","photos":[],"link":"","excerpt":"在上一篇 js 异步进化史之回调 我们了解到基于回调处理异步问题存在一些缺陷。那么 Promise 是什么？能够解决回调造成的问题吗？又会不会引入新的问题？下面我们一起来分析一下。","covers":["https://ws3.sinaimg.cn/large/006tKfTcgy1fo2arjy216j31jk0vzn1j.jpg","https://ws1.sinaimg.cn/large/006tKfTcgy1fo2c2khvv8j30oo0dwt9c.jpg","https://ws3.sinaimg.cn/large/006tKfTcgy1fo2hg2scibj310e0pe763.jpg"],"content":"<p>在上一篇 <a href=\"/js%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E5%9B%9E%E8%B0%83/\">js 异步进化史之回调</a> 我们了解到基于回调处理异步问题存在一些缺陷。那么 Promise 是什么？能够解决回调造成的问题吗？又会不会引入新的问题？下面我们一起来分析一下。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fo2arjy216j31jk0vzn1j.jpg\" alt=\"Promise\"></p>\n<h3 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise?\"></a>什么是 Promise?</h3><hr>\n<p>Promise 英文意思：承诺。嗯，一看就觉得靠谱！</p>\n<p>Promise 只有三种状态：未决议、resolve、reject，并且一旦决议，状态不可在更改。只能由未决议 &gt; resolve，或 未决议 &gt; reject，两条状态转换路线，不能逆转，resolve 也不能转为 reject。如图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fo2c2khvv8j30oo0dwt9c.jpg\" alt=\"图片\"></p>\n<p>小时候有玩过鞭炮的小朋友可以会想到，未决议状态不就像点燃鞭炮一样吗？要么成功爆炸(resolve)，要么是哑炮(reject)。</p>\n<p>没错，就是这样，但是我还是不明白 Promise 是什么？</p>\n<p>好吧，我们继续，你会明白的~</p>\n<p>I promise!</p>\n<h3 id=\"理解-Promise\"><a href=\"#理解-Promise\" class=\"headerlink\" title=\"理解 Promise\"></a>理解 Promise</h3><hr>\n<p>我们先放下对 Promise 概念的纠结，首先想想这两个问题：</p>\n<ol>\n<li>es6 提供的 Promise 基于底层实现的那些改变，能否通过回调等其他机制进行模拟？</li>\n<li>Promise 是为了解决什么问题而出现的？</li>\n</ol>\n<p>不急，我们一个一个问题来处理～</p>\n<h4 id=\"es6-之任务队列\"><a href=\"#es6-之任务队列\" class=\"headerlink\" title=\"es6 之任务队列\"></a>es6 之任务队列</h4><p>在 es6 中新增了一个名为<strong>任务队列</strong>的概念，该队列建立于事件循环队列之上。而 Promise 的异步特性正是基于任务队列。事件循环队列我们在<a href=\"https://winixt.me/js%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E5%9B%9E%E8%B0%83/\" target=\"_blank\" rel=\"noopener\">js 异步进化史之回调</a>已经介绍过，这里不在赘述，我们来详细分析下任务队列。</p>\n<p>大家来看看这段代码输出顺序是什么？（先有自己的答案再往下看）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'C'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'D'</span>);</span><br></pre></td></tr></table></figure>\n<p>正确顺序是 D &gt; B &gt; C &gt; A</p>\n<p>为什么？因为任务队列是建立在事件循环队列上的队列，也就是说….算了我也说不清，上图上图</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fo2hg2scibj310e0pe763.jpg\" alt=\"图片\"></p>\n<p>也就是说，js 引擎会优先处理任务队列的任务，直到任务任务队列为空才转而执行事件循环队列的事件。所以理论上说，任务循环可能会导致无限循环，进而导致程序饿死，无法转移到下一个事件循环 tick。</p>\n<p>注：这里主要为了方便理解，真实情况不是这样的，其实一个浏览器环境只能有一个事件循环，而一个事件循环可以多个任务队列，每个任务都有一个任务源）。相同任务源的任务，只能放到一个任务队列中。不同任务源的任务，可以放到不同任务队列中。</p>\n<p>是不是有种 vip 通道的感觉？【滑稽】</p>\n<h4 id=\"Promise-与-任务队列\"><a href=\"#Promise-与-任务队列\" class=\"headerlink\" title=\"Promise 与 任务队列\"></a>Promise 与 任务队列</h4><p>为什么 Promise 要基于任务队列呢？这样能解决什么问题？</p>\n<p>这是为了满足一些低延迟的异步操作。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(2).then(function(data) &#123;</span><br><span class=\"line\">  console.log(data)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种可以直接同步运行，但是又不得不异步运行的代码，你不希望它排一个长长的事件队列再执行吧？</p>\n<p>为什么说可以同步运行，但又不得不异步运行呢？</p>\n<p>请看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">request(<span class=\"string\">'http://example.com'</span>, boo);</span><br><span class=\"line\"></span><br><span class=\"line\">a++;</span><br></pre></td></tr></table></figure>\n<p>请问这里打印 0 还是 1？要看情况而定。如果 request 是同步的那么打印 0，如果是异步则打印 1。在真实的开发环境中遇到这种不确定因素会造成极大的麻烦。</p>\n<p>怎么办呢？有轻功</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    request(<span class=\"string\">'http://example.com'</span>, resolve);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func().then(boo);</span><br><span class=\"line\"></span><br><span class=\"line\">a++;</span><br></pre></td></tr></table></figure>\n<p>这样可以永远保证 console 输出为 1</p>\n<h4 id=\"Promise-之并发\"><a href=\"#Promise-之并发\" class=\"headerlink\" title=\"Promise 之并发\"></a>Promise 之并发</h4><p>想必大多数前端工程师都遇到过下面类似的情况吧？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data1, data2;</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(<span class=\"string\">'http://example.com?index=1'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  data1 = data;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data1 &amp;&amp; data2) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data1 + data2); <span class=\"comment\">// console 依赖于异步结果 data1 和 data2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(<span class=\"string\">'http://example.com?index=2'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  data2 = data;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data1 &amp;&amp; data2) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data1 + data2); <span class=\"comment\">// console 依赖于异步结果 data1 和 data2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这代码虽然没什么问题，但是看起来总不太优雅，语句 if (data1 &amp;&amp; data2) 存在于两个地方，如有改动，需要两个地方都改。让我们用 Promise 试试：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    ajax(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        resolve(data);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = request(<span class=\"string\">'http://example.com?index=1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = request(<span class=\"string\">'http://example.com?index=2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(...data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>是不是优雅很多😊</p>\n<h4 id=\"Promise-与回调\"><a href=\"#Promise-与回调\" class=\"headerlink\" title=\"Promise 与回调\"></a>Promise 与回调</h4><p>我们在上一篇<a href=\"/js%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E5%9B%9E%E8%B0%83/\">js 异步进化史之回调</a>中提到过这么一句话：</p>\n<p>回调相当于将代码扔进一个黑盒，发生什么你无从得知。当黑盒运行完了它的代码，自动会调用你的回调函数。</p>\n<p>而 Promise 却反过来”监听”黑盒的运行情况，”监听”到黑盒运行完了，就马上调用相应的函数。</p>\n<p>呃，有点难懂！</p>\n<p>好吧，上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三方 API（thirdAPI)，结束运行后，调用 func</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do somethind</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三方 API</span></span><br><span class=\"line\">thirdAPI(func)</span><br></pre></td></tr></table></figure>\n<p>以上是回调存在的一个信任的问题，我们无法保证第三方 API，在什么环境下调用我们的函数 func，出了错误我们也无法监听，等等一系列问题。（也就是把我们的代码扔进了黑盒）</p>\n<p>首先想想我们为什么不能在自己的环境下调用 func 呢？因为我们不知道 thirdAPI 什么时候能够运行完呀，因此不知道该什么时候调用 func 才好。</p>\n<p>既然这样，如果我们能够监听到 thirdAPI 运行完，岂不是可以在监听到 thirdAPI 运行完就可以调用我们的 func 了？就像：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fulfilled</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rejected</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三方 API</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">thirdAPI</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ajax(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      listener.emit(<span class=\"string\">'rejected'</span>, err)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      listener.emit(<span class=\"string\">'fulfilled'</span>, data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> listener;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> listener = thirdAPI();</span><br><span class=\"line\"></span><br><span class=\"line\">listener.on(<span class=\"string\">'fulfilled'</span>, fulfilled);</span><br><span class=\"line\">listener.on(<span class=\"string\">'rejected'</span>, rejected);</span><br></pre></td></tr></table></figure>\n<p>这就非常类似我们的”监听”黑盒功能了，但是要手动实现一个发布订阅模式 listener。</p>\n<p>改用 Promise 后：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fulfilled</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rejected</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三方 API</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">thirdAPI</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    ajax(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        reject(err)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nice</span></span><br><span class=\"line\">thirdAPI().then(fulfilled, rejected);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-链式流\"><a href=\"#Promise-链式流\" class=\"headerlink\" title=\"Promise 链式流\"></a>Promise 链式流</h4><p>Promise 出来这么久了，即使没有直接用过 Promise，相信也间接用过不少。例如，Fetch 就是基于 Promise 封装的，这块代码你应该很熟悉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'http://example.com?index=1'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.ok) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.json();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"Request Error\"</span>;</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的 then … then … catch 就是 Promise 的链式流。catch 稍后我们在介绍，这里先说下 then。</p>\n<p>运行 then 之后会发生什么呢？为什么可以一直 then 下去？</p>\n<p>运行 then 之后，会返回一个 Promise。具体来说是 Promise.resolve(/<em>then 的返回值</em>/)</p>\n<p>Promise.resolve 的作用:  返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。</p>\n<p>这里有个问题，虽然貌似部分解决跟踪回调时，脑子跳来跳去的问题，但是我想说的是 then 也烦呀，虽然没回调烦～。</p>\n<h4 id=\"Promise-错误处理\"><a href=\"#Promise-错误处理\" class=\"headerlink\" title=\"Promise 错误处理\"></a>Promise 错误处理</h4><p>Promise 的错误处理，可以将函数放在 then 的第二个参数上，也可以用 catch 捕获：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fulfilled</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rejected</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fulfilled</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then 的两个参数有默认值</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value; <span class=\"comment\">// 默认将 value 直接返回</span></span><br><span class=\"line\">&#125;，<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err; <span class=\"comment\">// 默认直接将 err 抛出</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>但是如果 catch 中也发生错误呢？由谁来捕获？所以这也算是 Promise 的一个缺陷。</p>\n<h4 id=\"Promise-适配版\"><a href=\"#Promise-适配版\" class=\"headerlink\" title=\"Promise 适配版\"></a>Promise 适配版</h4><p>当在不支持 Promise 的浏览器器中使用 Promise 时，可以使用相关的适配版，其定义了 Promise 及它的所有相关特性，例如，Native PromiseA。</p>\n<h3 id=\"Promise-API-概览\"><a href=\"#Promise-API-概览\" class=\"headerlink\" title=\"Promise API 概览\"></a>Promise API 概览</h3><hr>\n<p>上文已经零零散散展示了一些 Promise API 的用法，下面我们来总结一下。</p>\n<h4 id=\"new-Promise-…-构造器\"><a href=\"#new-Promise-…-构造器\" class=\"headerlink\" title=\"new Promise(…) 构造器\"></a>new Promise(…) 构造器</h4><p>Promise 构造函数接受一个函数作为参数。这个函数是同步调用的，并且接受两个参数（resolve 和 reject）作为回调，由 js 引擎提供，用以 Promise 决议。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'C'</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'D'</span>);</span><br></pre></td></tr></table></figure>\n<p>输出顺序为：A &gt; B &gt; D &gt; C</p>\n<p>reject 就是拒绝这个 promise，当发生错误或者其他异常的时候，就会调用 reject。</p>\n<p>resolve 可能是完成 promise，也可能是拒绝 promise。要视传入的参数而定，当传入的参数为非 promise、非tenable 的立即值，这个 promise 就会用这个值完成。</p>\n<p>但是，如果传给 resolve 的值是 promise 或 thenable，这个值将会被递归展开，并且 promise 将取其最终决议值或状态。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> errP = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Error Promise'</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve(errP);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成Promise'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">// Error Promsise</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-reject-…-和-Promise-resolve-…\"><a href=\"#Promise-reject-…-和-Promise-resolve-…\" class=\"headerlink\" title=\"Promise.reject(…) 和 Promise.resolve(…)\"></a>Promise.reject(…) 和 Promise.resolve(…)</h4><p>Promise.reject 用来创建一个被拒绝的 promise。不管传入什么参数 thenable 也好、promise 也好不会对其进行展开，最终决议都是拒绝。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  reject(<span class=\"string\">'some thing'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'some thing'</span>);<span class=\"comment\">// p1 和 p2 等价</span></span><br></pre></td></tr></table></figure>\n<p>Promise.resolve 用来创建一个已完成的 promise。与 Promise.reject 不同，如果传入值是thenable，会对值进行展开。最终的决议值可能是完成，也可能是拒绝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> errP = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Error Promise'</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(errP).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'完成Promise'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">// Error Promsise</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">3</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>注：如果传入的值是真正的 promise，Promise.resolve 会直接将这个值返回，不会做其他操作。</p>\n<h4 id=\"then-…-和-catch-…\"><a href=\"#then-…-和-catch-…\" class=\"headerlink\" title=\"then(…) 和 catch(…)\"></a>then(…) 和 catch(…)</h4><p>每个 Promise 实例都会有 then 和 catch 方法，通过这两个方法可以为 promise 注册完成或拒绝函数。promise 决议之后会调用其中一个函数，完成 或 拒绝。但是不会两个方法都调用，只能调用其中一个，且只调用一次。自然也都是异步的。</p>\n<p>then 接受两个函数作为参数，第一个用于完成，第二个用于拒绝。也都有默认值，如果有哪个参数没有传或者传入非函数值都会被默认函数取代。默认完成函数只是简单的将值返回，默认拒绝函数会简单的将出错原因抛出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// then 的两个参数有默认值</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value; <span class=\"comment\">// 默认将 value 直接返回</span></span><br><span class=\"line\">&#125;，<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err; <span class=\"comment\">// 默认直接将 err 抛出</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>catch 只接受一个拒绝函数作为参数，并自动默认替换回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// catch 和 then(null, function) 等价</span></span><br><span class=\"line\">p.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>then(…) 和 catch(…) 都会创建并返回的一个新的 promise，这个 promise 可用于实现 promise 的链式流控制。如果完成或拒绝回调中抛出异常，那么返回的 promise 是拒绝的。如果任意一个回调返回 非 promise、非 thenable 的立即值，那么这个值会当作返回 promise 的完成值。如果处理函数返回一个 promise 或 thenable，那么这个值将会被展开，并作为返回 promise 的决议值。</p>\n<h4 id=\"Promise-all-…-和-Promise-race-…\"><a href=\"#Promise-all-…-和-Promise-race-…\" class=\"headerlink\" title=\"Promise.all([…]) 和 Promise.race([…])\"></a>Promise.all([…]) 和 Promise.race([…])</h4><p>Promise.all([…]) he Promise.race([…]) 都会创建一个 promise 作为返回值，其决议值由传入的 promise 数组决定。</p>\n<p>Promise.all([…])，只有传入的所有 promise 都完成，返回的 promise 才能完成。如果有任何一个的 promise 被拒绝，那么返回的 promise 就立刻被拒绝，并且抛弃其他 promise 的值。如果完成，会得到一个数组，其中包含所有 promise 的完成值。如果拒绝，只会得到第一个被拒绝的 promise 的决绝值。</p>\n<p>Promise.race([…])，只要第一个 promise （完成或拒绝），那么返回的 promise 立即（完成或拒绝），并将第一个完成的 promise 的决议值，作为返回 promise 的决议值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p3 = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'error'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p3, p2, p1]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)； <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>注：若 Promise.all([…]) 传入空数组，它会立即完成。但 Promise.race([…]) 会挂，永远不会决议。</p>\n<p>ES6 Promise API 非常直观。至少足以处理最基本的一些异步情况，但也有它的局限性，下面我们来讨论一下。</p>\n<h3 id=\"Promise-局限\"><a href=\"#Promise-局限\" class=\"headerlink\" title=\"Promise 局限\"></a>Promise 局限</h3><hr>\n<p>首先是处理错误的顺序，前文我们已经讨论过了，可以翻回去看看。</p>\n<p>其次我觉的 then(…) then(…) then(…) 的很烦。虽然它部分解决了回调地狱的问题～</p>\n<p>还有其他比较细微的问题，我没有相应的实践不太好说，推荐各位看</p>\n<p><strong>《你不知道的 javascript 中卷》</strong></p>\n<p>至于上面的小问题怎么解决呢？请看下篇</p>\n<p>js异步进化史之 Generator</p>\n","categories":[{"name":"异步","slug":"异步","count":4,"path":"api/categories/异步.json"}],"tags":[{"name":"Promise","slug":"Promise","count":1,"path":"api/tags/Promise.json"}]}