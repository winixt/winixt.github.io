{"total":28,"pageSize":10,"pageCount":3,"data":[{"title":"多端共享实现","slug":"多端共享实现","date":"2019-03-31T16:00:00.000Z","updated":"2019-04-01T07:37:51.640Z","comments":true,"path":"api/articles/多端共享实现.json","excerpt":"","keywords":null,"cover":null,"content":"<p>首先让我们思考一个问题，你觉得各个平台是否希望自己的生态被打破，不同平台的特性是否应该归为一致？答案显然是否定的，每个大的企业都希望圈起自己的一个生态圈。那么跨平台的方案最终都需要面对各个平台间差异性的问题，这种差异性导致写一次到处跑的愿景几乎落空。为什么说是几乎呢？技术的发展路线谁也说不上，也许将来会出现划时代的技术。Flutter 可能就是这方面的鼻祖。</p>\n<h2 id=\"目前跨平台解决方案\"><a href=\"#目前跨平台解决方案\" class=\"headerlink\" title=\"目前跨平台解决方案\"></a>目前跨平台解决方案</h2><p>目前市面上跨平台的解决方案大致上可以分为两类：</p>\n<ul>\n<li>使用平台支持的 web 技术：这些解决方案基本上加载了应用程序中的移动浏览器，并在改浏览器中执行所有的逻辑。如 PhoneGap。</li>\n<li>本地跨平台：程序员编写的 code，可以自动转换为 Native 代码。这种方式的优点是近乎原生的性能，如 RN、weex 等。</li>\n</ul>\n<p>RN、weex 现在虽然有了比较大的生态，目前也逐步被大公司抛弃。平台的差异性太大，里面有太多的坑都很难绕过去。有时候排查一个问题需要深入了解 Android 和 IOS。同时熟知 Android 和 IOS 还有 RN 等语言的人才，市场上也没多少个。</p>\n<p>好消息是 FB 说准备对 react-native 重构，未来会更好🌹</p>\n<h2 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h2><p>Flutter 是 google 最近推出的跨平台开发框架。可以快速在 IOS、Android、Fuchsia上构建高质量的原生用户界面。那么 Flutter 是怎么解决跨平台的问题的呢？</p>\n<p>Flutter 跨平台最核心的部分是它的高性能渲染引擎（Flutter Engine）。Flutter 不使用浏览器技术，也不使用 Native 的原生控件，它使用自己的渲染引擎来绘制 widget。</p>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><p>首先是平台为小程序提供了完整的基础库，通过基础库、双线程渲染等方式，提升了小程序启动的体验。</p>\n<p>小程序也是通过 Webview + 原生组件实现的。与传统 webview 不同的是，小程序将采用双线程渲染，将喧嚷层和逻辑层分开。</p>\n<ul>\n<li>逻辑层：创建一个单独的线程去执行 js，在这个环境下执行的都是有关小程序业务逻辑的代码。</li>\n<li>渲染层：界面渲染相关的任务都在 webview 线程上执行，通过逻辑层的代码去控制渲染那些页面。一个小程序存在多个页面，所以渲染层存在多个 webview 线程。</li>\n</ul>\n<p>这么设计的目的是为了防止开发者使用一些浏览器提供的接口，例如：页面跳转、操作DOM、动态执行脚本。\b可以避免大部分在浏览器中的安全性问题。</p>\n<p>逻辑层和渲染层的通信会由 Native(微信客户端) 做中转，逻辑层发送网络请求也经由 Native 转发。</p>\n","text":"首先让我们思考一个问题，你觉得各个平台是否希望自己的生态被打破，不同平台的特性是否应该归为一致？答案显然是否定的，每个大的企业都希望圈起自己的一个生态圈。那么跨平台的方案最终都需要面对各个平台间差异性的问题，这种差异性导致写一次到处跑的愿景几乎落空。为什么说是几乎呢？技术的发展路","link":"","raw":null,"photos":[],"categories":[{"name":"native","slug":"native","count":1,"path":"api/categories/native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":1,"path":"api/tags/react-native.json"},{"name":"Flutter","slug":"Flutter","count":1,"path":"api/tags/Flutter.json"},{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}]},{"title":"js Map 和 WeakMap","slug":"Map 和 WeakMap","date":"2019-03-19T16:00:00.000Z","updated":"2019-03-20T10:13:12.404Z","comments":true,"path":"api/articles/Map 和 WeakMap.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>相比字面量对象，Map 的 key 可以是任意类型</li>\n<li>相比子面量对象，Map 可直接通过进行遍历，遍历的顺序为<code>key`</code>value`插入的顺序</li>\n<li>Map 可以方便的对子元素进行增删改查，内部存储其实为数组类型，基本操作的时间复杂度为 n</li>\n<li>WeakMap 键必须是对象，为对象的弱引用，在某些场景下可方便的避免内存泄漏</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"TL;DR相比字面量对象，Map 的 key 可以是任意类型相比子面量对象，Map 可直接通过进行遍历，遍历的顺序为key`value`插入的顺序Map 可以方便的对子元素进行增删改查，内部存储其实为数组类型，基本操作的时间复杂度为 nWeakMap 键必须是对象，为对象的弱引用","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"Map","slug":"Map","count":1,"path":"api/tags/Map.json"},{"name":"WeakMap","slug":"WeakMap","count":1,"path":"api/tags/WeakMap.json"}]},{"title":"js Number详解","slug":"js Number详解","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-20T02:26:17.709Z","comments":true,"path":"api/articles/js Number详解.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>Number 最大安全整数为 <code>Math.pow(2, 53) - 1</code></li>\n<li>Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 <code>Math.pow(2, 970)</code></li>\n<li>位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位</li>\n</ul>","keywords":null,"cover":"https://ws1.sinaimg.cn/large/006tKfTcly1g18c4pud5dj30hx02st9q.jpg","content":null,"text":"TL;DRNumber 最大安全整数为 Math.pow(2, 53) - 1Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 Math.pow(2, 970)位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位文章思","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"number","slug":"number","count":1,"path":"api/tags/number.json"}]},{"title":"重新认识requestAnimationFrame","slug":"重新认识requestAnimationFrame","date":"2019-03-14T16:00:00.000Z","updated":"2019-03-15T05:21:22.235Z","comments":true,"path":"api/articles/重新认识requestAnimationFrame.json","excerpt":"<p>引用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\" target=\"_blank\" rel=\"noopener\">MDN requestAnimationFrame</a>的一句话。</p>\n<blockquote>\n<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。回调函数执行次数通常是是每秒60次，与浏览器刷新屏幕次数相匹配。为了提高性能和电池寿命，因此在大多是浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的iframe里时，requestAnimationFrame 会被暂停。</p>\n</blockquote>\n<p>总的来说，requestAnimationFrame 就是为了解决动画问题而生的。那么使用 requestAnimationFrame 会带来那些好处呢？</p>","keywords":null,"cover":null,"content":null,"text":"引用MDN requestAnimationFrame的一句话。window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。回调函数执行次数通常是是每秒60次，与浏览器刷新屏幕次数相匹配。","link":"","raw":null,"photos":[],"categories":[{"name":"动画","slug":"动画","count":1,"path":"api/categories/动画.json"}],"tags":[{"name":"动画","slug":"动画","count":1,"path":"api/tags/动画.json"}]},{"title":"实现一个share state hook","slug":"实现一个share state hook","date":"2019-03-08T16:00:00.000Z","updated":"2019-03-09T07:09:48.874Z","comments":true,"path":"api/articles/实现一个share state hook.json","excerpt":"<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><hr>\n<p>react hooks 目前主要作用在于通过 useState 等函数实现<strong>状态逻辑</strong>共享，而不是状态共享。state 共享依旧需要 redux 等库去实现。redux 对于大型应用确实是一个不错的选择。但是写 action、reducers 难受呀？同意的请往下看，不同意的请摁 ⌘ + w。</p>","keywords":null,"cover":null,"content":null,"text":"现状react hooks 目前主要作用在于通过 useState 等函数实现状态逻辑共享，而不是状态共享。state 共享依旧需要 redux 等库去实现。redux 对于大型应用确实是一个不错的选择。但是写 action、reducers 难受呀？同意的请往下看，不同意的请摁","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"hooks","slug":"hooks","count":1,"path":"api/tags/hooks.json"}]},{"title":"理解apply,call,bind","slug":"理解apply,call,bind","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-04T05:37:34.724Z","comments":true,"path":"api/articles/理解apply,call,bind.json","excerpt":"<p>之前对 js 的 apply、call、bind 方法零零散散有过一些了解，知道它们可以改变函数运行时的 this。今天来深入理解一番。</p>\n<p>其实很多人心想不就是绑定 this 嘛，有什么的。</p>\n<p>好，那么这句代码何解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.apply.bind(Math.max, null);</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"之前对 js 的 apply、call、bind 方法零零散散有过一些了解，知道它们可以改变函数运行时的 this。今天来深入理解一番。其实很多人心想不就是绑定 this 嘛，有什么的。好，那么这句代码何解？1<br>Function.apply.bind(Math.max, n","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"apply","slug":"apply","count":1,"path":"api/tags/apply.json"},{"name":"call","slug":"call","count":1,"path":"api/tags/call.json"},{"name":"bind","slug":"bind","count":1,"path":"api/tags/bind.json"}]},{"title":"react生命周期","slug":"react生命周期","date":"2019-02-28T16:00:00.000Z","updated":"2019-03-01T09:23:25.162Z","comments":true,"path":"api/articles/react生命周期.json","excerpt":"<p>react在 ^16.4 版本进行生命周期的变更，废除了 <code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUpdate</code>，新引入了两个生命周期函数 <code>getDerivedStateFromProps</code>,<code>getSnapshotBeforeUpdate</code>。</p>","keywords":null,"cover":"https://ws2.sinaimg.cn/large/006tKfTcly1g0n8wrg0v1j30uk0hldi8.jpg","content":null,"text":"react在 ^16.4 版本进行生命周期的变更，废除了 componentWillMount,componentWillReceiveProps,componentWillUpdate，新引入了两个生命周期函数 getDerivedStateFromProps,getSnaps","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"生命周期","slug":"生命周期","count":1,"path":"api/tags/生命周期.json"}]},{"title":"react事件系统","slug":"react事件系统","date":"2019-02-27T16:00:00.000Z","updated":"2019-03-01T04:00:35.082Z","comments":true,"path":"api/articles/react事件系统.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>react16.8.3</li>\n<li>react 事件系统分为<code>事件注册</code>和<code>事件分发</code>两个阶段。</li>\n<li>事件注册阶段将<strong>大部分</strong>事件绑定到 document，在事件分发阶段调用 <code>dispatchEvent</code>进行事件捕获、事件冒泡分发。</li>\n<li>事件分发阶段会先根据事件类型调用对应 EventPlugin 进行事件合成，捕获和冒泡阶段会执行的 listener 都会存储到 event._dispatchListeners</li>\n</ul>","keywords":null,"cover":"https://ws1.sinaimg.cn/large/006tKfTcly1g0mfic97rnj315i0ck43w.jpg","content":null,"text":"TL;DRreact16.8.3react 事件系统分为事件注册和事件分发两个阶段。事件注册阶段将大部分事件绑定到 document，在事件分发阶段调用 dispatchEvent进行事件捕获、事件冒泡分发。事件分发阶段会先根据事件类型调用对应 EventPlugin 进行事件合","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"事件系统","slug":"事件系统","count":1,"path":"api/tags/事件系统.json"}]},{"title":"深入理解z-index","slug":"深入理解z-index","date":"2019-02-24T04:20:08.115Z","updated":"2019-02-24T04:20:08.115Z","comments":true,"path":"api/articles/深入理解z-index.json","excerpt":"<p>z-index 简单呀，想显示在上面给个大点的整数不久行了吗❓❓❓</p>\n<p>我们想的还是简单了点，这就好像写了一段能跑的代码，但是不知道它是怎么跑起来的，这就是新手和大佬的差距。要学的还很多，且勿骄勿躁，与君共勉！</p>","keywords":null,"cover":"https://ws4.sinaimg.cn/large/006tNc79gy1fo4i47weplj30jg0dcq3i.jpg","content":null,"text":"z-index 简单呀，想显示在上面给个大点的整数不久行了吗❓❓❓我们想的还是简单了点，这就好像写了一段能跑的代码，但是不知道它是怎么跑起来的，这就是新手和大佬的差距。要学的还很多，且勿骄勿躁，与君共勉！ [Figure] 可以看到 opacity 使 z-index 起作用，形","link":"","raw":null,"photos":[],"categories":[{"name":"css","slug":"css","count":2,"path":"api/categories/css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"},{"name":"z-index","slug":"z-index","count":1,"path":"api/tags/z-index.json"}]},{"title":"浏览器加载文件及其解析顺序","slug":"浏览器加载文件及其解析运行顺序","date":"2019-02-24T04:20:08.114Z","updated":"2019-02-25T04:09:07.524Z","comments":true,"path":"api/articles/浏览器加载文件及其解析运行顺序.json","excerpt":"<h3 id=\"浏览器加载文件及其解析顺序\"><a href=\"#浏览器加载文件及其解析顺序\" class=\"headerlink\" title=\"浏览器加载文件及其解析顺序\"></a>浏览器加载文件及其解析顺序</h3><hr>\n<ol>\n<li><p>用户输入网址（假设是个 HTML 页面，并且是首次访问），浏览器向服务器发出请求</p>\n</li>\n<li><p>下载 HTML，并解析执行，逐步构建 DOM 树</p>\n</li>\n<li><p>\u0010如果发现有外部 css 文件，进行异步加载，不会阻塞 HTML 的解析</p>\n<p>注：如果使用 HTTP/2 推送技术，可以提前进行资源的推送</p>","keywords":null,"cover":null,"content":null,"text":"浏览器加载文件及其解析顺序用户输入网址（假设是个 HTML 页面，并且是首次访问），浏览器向服务器发出请求下载 HTML，并解析执行，逐步构建 DOM 树\u0010如果发现有外部 css 文件，进行异步加载，不会阻塞 HTML 的解析注：如果使用 HTTP/2 推送技术，可以提前进行资源","link":"","raw":null,"photos":[],"categories":[{"name":"文件加载顺序","slug":"文件加载顺序","count":1,"path":"api/categories/文件加载顺序.json"}],"tags":[{"name":"文件加载顺序","slug":"文件加载顺序","count":1,"path":"api/tags/文件加载顺序.json"}]}]}