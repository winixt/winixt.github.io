{"total":29,"pageSize":10,"pageCount":3,"data":[{"title":"实时通信技术","slug":"实时通信技术","date":"2019-04-01T16:00:00.000Z","updated":"2019-04-02T05:18:29.155Z","comments":true,"path":"api/articles/实时通信技术.json","excerpt":"<p>由于浏览器的限制，web通信过程都是客户端先发起请求，服务器再进行响应。如果需要做到即时通信（即服务器可以将数据更新实时推送到客户端），需要借助其他方式进行实现。目前实现 web 实时通信的方法主要有四种：轮询、长轮询、长链接(SSE)、websocket。总体上可以分为两类，一类是基于 http 实现的，如轮询、长轮询、SSE，另一类不是基于 http 实现的。即 websocket。</p>","keywords":null,"cover":null,"content":null,"text":"由于浏览器的限制，web通信过程都是客户端先发起请求，服务器再进行响应。如果需要做到即时通信（即服务器可以将数据更新实时推送到客户端），需要借助其他方式进行实现。目前实现 web 实时通信的方法主要有四种：轮询、长轮询、长链接(SSE)、websocket。总体上可以分为两类，一","link":"","raw":null,"photos":[],"categories":[{"name":"websocket","slug":"websocket","count":1,"path":"api/categories/websocket.json"}],"tags":[{"name":"轮询","slug":"轮询","count":1,"path":"api/tags/轮询.json"},{"name":"长轮询","slug":"长轮询","count":1,"path":"api/tags/长轮询.json"},{"name":"长链接","slug":"长链接","count":1,"path":"api/tags/长链接.json"},{"name":"websocket","slug":"websocket","count":1,"path":"api/tags/websocket.json"}]},{"title":"多端共享实现","slug":"多端共享实现","date":"2019-03-31T16:00:00.000Z","updated":"2019-04-02T03:19:23.997Z","comments":true,"path":"api/articles/多端共享实现.json","excerpt":"<p>首先让我们思考一个问题，你觉得各个平台是否希望自己的生态被打破，不同平台的特性是否应该归为一致？答案显然是否定的，每个大的企业都希望圈起自己的一个生态圈。那么跨平台的方案最终都需要面对各个平台间差异性的问题，这种差异性导致写一次到处跑的愿景几乎落空。为什么说是几乎呢？技术的发展路线谁也说不上，也许将来会出现划时代的技术。Flutter 可能就是这方面的鼻祖。</p>","keywords":null,"cover":null,"content":null,"text":"首先让我们思考一个问题，你觉得各个平台是否希望自己的生态被打破，不同平台的特性是否应该归为一致？答案显然是否定的，每个大的企业都希望圈起自己的一个生态圈。那么跨平台的方案最终都需要面对各个平台间差异性的问题，这种差异性导致写一次到处跑的愿景几乎落空。为什么说是几乎呢？技术的发展路","link":"","raw":null,"photos":[],"categories":[{"name":"native","slug":"native","count":1,"path":"api/categories/native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":1,"path":"api/tags/react-native.json"},{"name":"Flutter","slug":"Flutter","count":1,"path":"api/tags/Flutter.json"},{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}]},{"title":"js Map 和 WeakMap","slug":"Map 和 WeakMap","date":"2019-03-19T16:00:00.000Z","updated":"2019-03-20T10:13:12.404Z","comments":true,"path":"api/articles/Map 和 WeakMap.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>相比字面量对象，Map 的 key 可以是任意类型</li>\n<li>相比子面量对象，Map 可直接通过进行遍历，遍历的顺序为<code>key`</code>value`插入的顺序</li>\n<li>Map 可以方便的对子元素进行增删改查，内部存储其实为数组类型，基本操作的时间复杂度为 n</li>\n<li>WeakMap 键必须是对象，为对象的弱引用，在某些场景下可方便的避免内存泄漏</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"TL;DR相比字面量对象，Map 的 key 可以是任意类型相比子面量对象，Map 可直接通过进行遍历，遍历的顺序为key`value`插入的顺序Map 可以方便的对子元素进行增删改查，内部存储其实为数组类型，基本操作的时间复杂度为 nWeakMap 键必须是对象，为对象的弱引用","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"Map","slug":"Map","count":1,"path":"api/tags/Map.json"},{"name":"WeakMap","slug":"WeakMap","count":1,"path":"api/tags/WeakMap.json"}]},{"title":"js Number详解","slug":"js Number详解","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-20T02:26:17.709Z","comments":true,"path":"api/articles/js Number详解.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>Number 最大安全整数为 <code>Math.pow(2, 53) - 1</code></li>\n<li>Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 <code>Math.pow(2, 970)</code></li>\n<li>位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位</li>\n</ul>","keywords":null,"cover":"https://ws1.sinaimg.cn/large/006tKfTcly1g18c4pud5dj30hx02st9q.jpg","content":null,"text":"TL;DRNumber 最大安全整数为 Math.pow(2, 53) - 1Number.MAX_VALUE round 成 Infinity 至少加上能被四舍五入到 Math.pow(2, 970)位运算符处理数据之前需要转换为32位进行处理，处理完后再转换为 64 位文章思","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"number","slug":"number","count":1,"path":"api/tags/number.json"}]},{"title":"重新认识requestAnimationFrame","slug":"重新认识requestAnimationFrame","date":"2019-03-14T16:00:00.000Z","updated":"2019-03-15T05:21:22.235Z","comments":true,"path":"api/articles/重新认识requestAnimationFrame.json","excerpt":"<p>引用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\" target=\"_blank\" rel=\"noopener\">MDN requestAnimationFrame</a>的一句话。</p>\n<blockquote>\n<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。回调函数执行次数通常是是每秒60次，与浏览器刷新屏幕次数相匹配。为了提高性能和电池寿命，因此在大多是浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的iframe里时，requestAnimationFrame 会被暂停。</p>\n</blockquote>\n<p>总的来说，requestAnimationFrame 就是为了解决动画问题而生的。那么使用 requestAnimationFrame 会带来那些好处呢？</p>","keywords":null,"cover":null,"content":null,"text":"引用MDN requestAnimationFrame的一句话。window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。回调函数执行次数通常是是每秒60次，与浏览器刷新屏幕次数相匹配。","link":"","raw":null,"photos":[],"categories":[{"name":"动画","slug":"动画","count":1,"path":"api/categories/动画.json"}],"tags":[{"name":"动画","slug":"动画","count":1,"path":"api/tags/动画.json"}]},{"title":"实现一个share state hook","slug":"实现一个share state hook","date":"2019-03-08T16:00:00.000Z","updated":"2019-03-09T07:09:48.874Z","comments":true,"path":"api/articles/实现一个share state hook.json","excerpt":"<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><hr>\n<p>react hooks 目前主要作用在于通过 useState 等函数实现<strong>状态逻辑</strong>共享，而不是状态共享。state 共享依旧需要 redux 等库去实现。redux 对于大型应用确实是一个不错的选择。但是写 action、reducers 难受呀？同意的请往下看，不同意的请摁 ⌘ + w。</p>","keywords":null,"cover":null,"content":null,"text":"现状react hooks 目前主要作用在于通过 useState 等函数实现状态逻辑共享，而不是状态共享。state 共享依旧需要 redux 等库去实现。redux 对于大型应用确实是一个不错的选择。但是写 action、reducers 难受呀？同意的请往下看，不同意的请摁","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"hooks","slug":"hooks","count":1,"path":"api/tags/hooks.json"}]},{"title":"理解apply,call,bind","slug":"理解apply,call,bind","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-04T05:37:34.724Z","comments":true,"path":"api/articles/理解apply,call,bind.json","excerpt":"<p>之前对 js 的 apply、call、bind 方法零零散散有过一些了解，知道它们可以改变函数运行时的 this。今天来深入理解一番。</p>\n<p>其实很多人心想不就是绑定 this 嘛，有什么的。</p>\n<p>好，那么这句代码何解？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.apply.bind(Math.max, null);</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"之前对 js 的 apply、call、bind 方法零零散散有过一些了解，知道它们可以改变函数运行时的 this。今天来深入理解一番。其实很多人心想不就是绑定 this 嘛，有什么的。好，那么这句代码何解？1<br>Function.apply.bind(Math.max, n","link":"","raw":null,"photos":[],"categories":[{"name":"js","slug":"js","count":3,"path":"api/categories/js.json"}],"tags":[{"name":"apply","slug":"apply","count":1,"path":"api/tags/apply.json"},{"name":"call","slug":"call","count":1,"path":"api/tags/call.json"},{"name":"bind","slug":"bind","count":1,"path":"api/tags/bind.json"}]},{"title":"react生命周期","slug":"react生命周期","date":"2019-02-28T16:00:00.000Z","updated":"2019-03-01T09:23:25.162Z","comments":true,"path":"api/articles/react生命周期.json","excerpt":"<p>react在 ^16.4 版本进行生命周期的变更，废除了 <code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUpdate</code>，新引入了两个生命周期函数 <code>getDerivedStateFromProps</code>,<code>getSnapshotBeforeUpdate</code>。</p>","keywords":null,"cover":"https://ws2.sinaimg.cn/large/006tKfTcly1g0n8wrg0v1j30uk0hldi8.jpg","content":null,"text":"react在 ^16.4 版本进行生命周期的变更，废除了 componentWillMount,componentWillReceiveProps,componentWillUpdate，新引入了两个生命周期函数 getDerivedStateFromProps,getSnaps","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"生命周期","slug":"生命周期","count":1,"path":"api/tags/生命周期.json"}]},{"title":"react事件系统","slug":"react事件系统","date":"2019-02-27T16:00:00.000Z","updated":"2019-03-01T04:00:35.082Z","comments":true,"path":"api/articles/react事件系统.json","excerpt":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><hr>\n<ul>\n<li>react16.8.3</li>\n<li>react 事件系统分为<code>事件注册</code>和<code>事件分发</code>两个阶段。</li>\n<li>事件注册阶段将<strong>大部分</strong>事件绑定到 document，在事件分发阶段调用 <code>dispatchEvent</code>进行事件捕获、事件冒泡分发。</li>\n<li>事件分发阶段会先根据事件类型调用对应 EventPlugin 进行事件合成，捕获和冒泡阶段会执行的 listener 都会存储到 event._dispatchListeners</li>\n</ul>","keywords":null,"cover":"https://ws1.sinaimg.cn/large/006tKfTcly1g0mfic97rnj315i0ck43w.jpg","content":null,"text":"TL;DRreact16.8.3react 事件系统分为事件注册和事件分发两个阶段。事件注册阶段将大部分事件绑定到 document，在事件分发阶段调用 dispatchEvent进行事件捕获、事件冒泡分发。事件分发阶段会先根据事件类型调用对应 EventPlugin 进行事件合","link":"","raw":null,"photos":[],"categories":[{"name":"react","slug":"react","count":5,"path":"api/categories/react.json"}],"tags":[{"name":"事件系统","slug":"事件系统","count":1,"path":"api/tags/事件系统.json"}]},{"title":"深入理解z-index","slug":"深入理解z-index","date":"2019-02-24T04:20:08.115Z","updated":"2019-02-24T04:20:08.115Z","comments":true,"path":"api/articles/深入理解z-index.json","excerpt":"<p>z-index 简单呀，想显示在上面给个大点的整数不久行了吗❓❓❓</p>\n<p>我们想的还是简单了点，这就好像写了一段能跑的代码，但是不知道它是怎么跑起来的，这就是新手和大佬的差距。要学的还很多，且勿骄勿躁，与君共勉！</p>","keywords":null,"cover":"https://ws4.sinaimg.cn/large/006tNc79gy1fo4i47weplj30jg0dcq3i.jpg","content":null,"text":"z-index 简单呀，想显示在上面给个大点的整数不久行了吗❓❓❓我们想的还是简单了点，这就好像写了一段能跑的代码，但是不知道它是怎么跑起来的，这就是新手和大佬的差距。要学的还很多，且勿骄勿躁，与君共勉！ [Figure] 可以看到 opacity 使 z-index 起作用，形","link":"","raw":null,"photos":[],"categories":[{"name":"css","slug":"css","count":2,"path":"api/categories/css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"},{"name":"z-index","slug":"z-index","count":1,"path":"api/tags/z-index.json"}]}]}